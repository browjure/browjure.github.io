shadow$provide.module$node_modules$$math_DOT_gl$culling$dist$es5$algorithms$bounding_box_from_points=function(global,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if("undefined"===typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},
e:function(_e){throw _e;},f:allowArrayLike}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=o[Symbol.iterator]()},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it["return"])it["return"]()}finally{if(didErr)throw err;}}}}function _unsupportedIterableToArray(o,
minLen){if(o){if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);"Object"===n&&o.constructor&&(n=o.constructor.name);if("Map"===n||"Set"===n)return Array.from(o);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
Object.defineProperty(exports,"__esModule",{value:!0});exports.makeOrientedBoundingBoxFromPoints=function(positions){var result=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new _orientedBoundingBox["default"];if(!positions||0===positions.length)return result.halfAxes=new _core.Matrix3([0,0,0,0,0,0,0,0,0]),result.center=new _core.Vector3,result;var length=positions.length,meanPoint=new _core.Vector3(0,0,0),_iterator=_createForOfIteratorHelper(positions),_step;try{for(_iterator.s();!(_step=
_iterator.n()).done;)meanPoint.add(_step.value)}catch(err){_iterator.e(err)}finally{_iterator.f()}length=1/length;meanPoint.multiplyByScalar(length);var exz=_step=_iterator=0,eyy=0,eyz=0,ezz=0,_iterator2=_createForOfIteratorHelper(positions),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var p=scratchVector2.copy(_step2.value).subtract(meanPoint);_iterator+=p.x*p.x;_step+=p.x*p.y;exz+=p.x*p.z;eyy+=p.y*p.y;eyz+=p.y*p.z;ezz+=p.z*p.z}}catch(err){_iterator2.e(err)}finally{_iterator2.f()}_step*=
length;exz*=length;eyz*=length;meanPoint=scratchCovarianceResult;meanPoint[0]=_iterator*length;meanPoint[1]=_step;meanPoint[2]=exz;meanPoint[3]=_step;meanPoint[4]=eyy*length;meanPoint[5]=eyz;meanPoint[6]=exz;meanPoint[7]=eyz;meanPoint[8]=ezz*length;meanPoint=(0,_computeEigenDecomposition["default"])(meanPoint,scratchEigenResult).unitary;p=result.halfAxes.copy(meanPoint);meanPoint=p.getColumn(0,scratchVector4);_step2=p.getColumn(1,scratchVector5);p=p.getColumn(2,scratchVector6);length=-Number.MAX_VALUE;
_iterator=-Number.MAX_VALUE;_step=-Number.MAX_VALUE;eyz=eyy=exz=Number.MAX_VALUE;ezz=_createForOfIteratorHelper(positions);var _step3;try{for(ezz.s();!(_step3=ezz.n()).done;){var _position2=_step3.value;length=Math.max(_position2.dot(meanPoint),length);_iterator=Math.max(_position2.dot(_step2),_iterator);_step=Math.max(_position2.dot(p),_step);exz=Math.min(_position2.dot(meanPoint),exz);eyy=Math.min(_position2.dot(_step2),eyy);eyz=Math.min(_position2.dot(p),eyz)}}catch(err){ezz.e(err)}finally{ezz.f()}meanPoint=
meanPoint.multiplyByScalar(.5*(exz+length));_step2=_step2.multiplyByScalar(.5*(eyy+_iterator));p=p.multiplyByScalar(.5*(eyz+_step));result.center.copy(meanPoint).add(_step2).add(p);_step3=scratchVector3.set(length-exz,_iterator-eyy,_step-eyz).multiplyByScalar(.5);result.halfAxes.multiplyByScalar(_step3);return result};exports.makeAxisAlignedBoundingBoxFromPoints=function(positions){var result=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new _axisAlignedBoundingBox["default"];if(!positions||
0===positions.length)return result.minimum.set(0,0,0),result.maximum.set(0,0,0),result.center.set(0,0,0),result.halfDiagonal.set(0,0,0),result;var minimumX=positions[0][0],minimumY=positions[0][1],minimumZ=positions[0][2],maximumX=positions[0][0],maximumY=positions[0][1],maximumZ=positions[0][2],_iterator4=_createForOfIteratorHelper(positions),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var p=_step4.value,x=p[0],y=p[1],z=p[2];minimumX=Math.min(x,minimumX);maximumX=Math.max(x,maximumX);
minimumY=Math.min(y,minimumY);maximumY=Math.max(y,maximumY);minimumZ=Math.min(z,minimumZ);maximumZ=Math.max(z,maximumZ)}}catch(err){_iterator4.e(err)}finally{_iterator4.f()}result.minimum.set(minimumX,minimumY,minimumZ);result.maximum.set(maximumX,maximumY,maximumZ);result.center.copy(result.minimum).add(result.maximum).scale(.5);result.halfDiagonal.copy(result.maximum).subtract(result.center);return result};var _core=require("module$node_modules$$math_DOT_gl$core$dist$es5$index"),_computeEigenDecomposition=
global(require("module$node_modules$$math_DOT_gl$culling$dist$es5$algorithms$compute_eigen_decomposition")),_orientedBoundingBox=global(require("module$node_modules$$math_DOT_gl$culling$dist$es5$lib$oriented_bounding_box")),_axisAlignedBoundingBox=global(require("module$node_modules$$math_DOT_gl$culling$dist$es5$lib$axis_aligned_bounding_box")),scratchVector2=new _core.Vector3,scratchVector3=new _core.Vector3,scratchVector4=new _core.Vector3,scratchVector5=new _core.Vector3,scratchVector6=new _core.Vector3,
scratchCovarianceResult=new _core.Matrix3,scratchEigenResult={diagonal:new _core.Matrix3,unitary:new _core.Matrix3}}
//# sourceMappingURL=module$node_modules$$math_DOT_gl$culling$dist$es5$algorithms$bounding_box_from_points.js.map
