shadow$provide.module$node_modules$$deck_DOT_gl$core$dist$es5$shaderlib$shadow$shadow=function(global,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if("undefined"===typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},e:function(_e){throw _e;
},f:allowArrayLike}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=o[Symbol.iterator]()},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it["return"])it["return"]()}finally{if(didErr)throw err;}}}}function _unsupportedIterableToArray(o,
minLen){if(o){if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);"Object"===n&&o.constructor&&(n=o.constructor.name);if("Map"===n||"Set"===n)return Array.from(o);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function createShadowUniforms(){for(var opts=
0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},context=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},uniforms={shadow_uDrawShadowMap:!!opts.drawToShadowMap,shadow_uUseShadowMap:opts.shadowMaps?0<opts.shadowMaps.length:!1,shadow_uColor:opts.shadowColor||DEFAULT_SHADOW_COLOR,shadow_uLightId:opts.shadowLightId||0,shadow_uLightCount:opts.shadowMatrices.length},center=getMemoizedViewportCenterPosition({viewport:opts.viewport,center:context.project_uCenter}),projectCenters=[],viewProjectionMatrices=
getMemoizedViewProjectionMatrices({shadowMatrices:opts.shadowMatrices,viewport:opts.viewport}).slice(),i=0;i<opts.shadowMatrices.length;i++){var viewProjectionMatrix=viewProjectionMatrices[i],viewProjectionMatrixCentered=viewProjectionMatrix.clone().translate((new _math.Vector3(opts.viewport.center)).negate());context.project_uCoordinateSystem===_constants.COORDINATE_SYSTEM.LNGLAT&&context.project_uProjectionMode===_constants.PROJECTION_MODE.WEB_MERCATOR?(viewProjectionMatrices[i]=viewProjectionMatrixCentered,
projectCenters[i]=center):(viewProjectionMatrices[i]=viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX),projectCenters[i]=viewProjectionMatrixCentered.transform(center))}for(context=0;context<viewProjectionMatrices.length;context++)uniforms["shadow_uViewProjectionMatrices[".concat(context,"]")]=viewProjectionMatrices[context],uniforms["shadow_uProjectCenters[".concat(context,"]")]=projectCenters[context],opts.shadowMaps&&0<opts.shadowMaps.length?uniforms["shadow_uShadowMap".concat(context)]=
opts.shadowMaps[context]:uniforms["shadow_uShadowMap".concat(context)]=opts.dummyShadowMap;return uniforms}module=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;var _toConsumableArray2=module(require("module$node_modules$$babel$runtime$helpers$toConsumableArray")),_slicedToArray2=module(require("module$node_modules$$babel$runtime$helpers$slicedToArray")),_constants=require("module$node_modules$$deck_DOT_gl$core$dist$es5$lib$constants");
global=module(require("module$node_modules$$deck_DOT_gl$core$dist$es5$shaderlib$project$project"));var _math=require("module$node_modules$math_DOT_gl$dist$es5$index");module=module(require("module$node_modules$$deck_DOT_gl$core$dist$es5$utils$memoize"));var _webMercator=require("module$node_modules$$math_DOT_gl$web_mercator$dist$es5$index"),getMemoizedViewportCenterPosition=(0,module["default"])(function(_ref){var center=_ref.center;return(new _math.Matrix4(_ref.viewport.viewProjectionMatrix)).invert().transform(center)}),
getMemoizedViewProjectionMatrices=(0,module["default"])(function(_ref2){var viewport=_ref2.viewport;_ref2=_ref2.shadowMatrices;var projectionMatrices=[],pixelUnprojectionMatrix=viewport.pixelUnprojectionMatrix,farZ=viewport.isGeospatial?void 0:1,corners=[[0,0,farZ],[viewport.width,0,farZ],[0,viewport.height,farZ],[viewport.width,viewport.height,farZ],[0,0,-1],[viewport.width,0,-1],[0,viewport.height,-1],[viewport.width,viewport.height,-1]].map(function(pixel){var _xyz=(0,_slicedToArray2["default"])(pixel,
3);pixel=_xyz[0];var y=_xyz[1];_xyz=_xyz[2];pixel=(0,_webMercator.pixelsToWorld)([pixel,y,_xyz],pixelUnprojectionMatrix);pixel=Number.isFinite(_xyz)?pixel:[pixel[0],pixel[1],0];return pixel});_ref2=_createForOfIteratorHelper(_ref2);var _step;try{for(farZ=function(){var shadowMatrix=_step.value,viewMatrix=shadowMatrix.clone().translate((new _math.Vector3(viewport.center)).negate()),positions=corners.map(function(corner){return viewMatrix.transform(corner)});positions=(new _math.Matrix4).ortho({left:Math.min.apply(Math,
(0,_toConsumableArray2["default"])(positions.map(function(position){return position[0]}))),right:Math.max.apply(Math,(0,_toConsumableArray2["default"])(positions.map(function(position){return position[0]}))),bottom:Math.min.apply(Math,(0,_toConsumableArray2["default"])(positions.map(function(position){return position[1]}))),top:Math.max.apply(Math,(0,_toConsumableArray2["default"])(positions.map(function(position){return position[1]}))),near:Math.min.apply(Math,(0,_toConsumableArray2["default"])(positions.map(function(position){return-position[2]}))),
far:Math.max.apply(Math,(0,_toConsumableArray2["default"])(positions.map(function(position){return-position[2]})))});projectionMatrices.push(positions.multiplyRight(shadowMatrix))},_ref2.s();!(_step=_ref2.n()).done;)farZ()}catch(err){_ref2.e(err)}finally{_ref2.f()}return projectionMatrices}),DEFAULT_SHADOW_COLOR=[0,0,0,1],VECTOR_TO_POINT_MATRIX=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0];exports["default"]={name:"shadow",dependencies:[global["default"]],vs:"\nconst int max_lights \x3d 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i \x3d 0; i \x3c max_lights; i++) {\n      if(i \x3c int(shadow_uLightCount)) {\n        vec4 shadowMap_position \x3d project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] \x3d (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n",
fs:"\nconst int max_lights \x3d 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift \x3d vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift \x3d 1.0 / bitPackShift;\nconst vec4 bitMask \x3d vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth \x3d texture2D(shadowMap, position.xy);\n\n  float z \x3d dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth \x3d fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -\x3d rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha \x3d 0.0;\n    shadowAlpha +\x3d shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount \x3e 1.0) {\n      shadowAlpha +\x3d shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *\x3d shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha \x3d shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n",
inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    position \x3d shadow_setVertexPosition(geometry.position);\n    ","fs:DECKGL_FILTER_COLOR":"\n    color \x3d shadow_filterShadowColor(color);\n    "},getUniforms:function(){var opts=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},context=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(opts.drawToShadowMap||opts.shadowMaps&&0<opts.shadowMaps.length){var shadowUniforms={},_opts$shadowEnabled=opts.shadowEnabled;(void 0===_opts$shadowEnabled||
_opts$shadowEnabled)&&opts.shadowMatrices&&0<opts.shadowMatrices.length?Object.assign(shadowUniforms,createShadowUniforms(opts,context)):Object.assign(shadowUniforms,{shadow_uDrawShadowMap:!1,shadow_uUseShadowMap:!1});return shadowUniforms}return{}}}}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$core$dist$es5$shaderlib$shadow$shadow.js.map
