shadow$provide.module$node_modules$$deck_DOT_gl$aggregation_layers$dist$es5$gpu_grid_layer$gpu_grid_cell_layer_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-vertex-shader\n#define RANGE_COUNT 6\n\nin vec3 positions;\nin vec3 normals;\n\nin vec4 colors;\nin vec4 elevations;\nin vec3 instancePickingColors;\nuniform vec2 offset;\nuniform bool extruded;\nuniform float cellSize;\nuniform float coverage;\nuniform float opacity;\nuniform float elevationScale;\n\nuniform ivec2 gridSize;\nuniform vec2 gridOrigin;\nuniform vec2 gridOriginLow;\nuniform vec2 gridOffset;\nuniform vec2 gridOffsetLow;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 elevationRange;\nuniform vec2 colorDomain;\nuniform bool colorDomainValid;\nuniform vec2 elevationDomain;\nuniform bool elevationDomainValid;\n\nlayout(std140) uniform;\nuniform ColorData\n{\n  vec4 maxMinCount;\n} colorData;\nuniform ElevationData\n{\n  vec4 maxMinCount;\n} elevationData;\n\n#define EPSILON 0.00001\nout vec4 vColor;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor \x3d vec4(0., 0., 0., 0.);\n  if (value \x3e\x3d (domain.x - EPSILON) \x26\x26 value \x3c\x3d (domain.y + EPSILON)) {\n    float domainRange \x3d domain.y - domain.x;\n    if (domainRange \x3c\x3d 0.) {\n      outColor \x3d colorRange[0];\n    } else {\n      float rangeCount \x3d float(RANGE_COUNT);\n      float rangeStep \x3d domainRange / rangeCount;\n      float idx \x3d floor((value - domain.x) / rangeStep);\n      idx \x3d clamp(idx, 0., rangeCount - 1.);\n      int intIdx \x3d int(idx);\n      outColor \x3d colorRange[intIdx];\n    }\n  }\n  return outColor;\n}\n\nfloat linearScale(vec2 domain, vec2 range, float value) {\n  if (value \x3e\x3d (domain.x - EPSILON) \x26\x26 value \x3c\x3d (domain.y + EPSILON)) {\n    return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;\n  }\n  return -1.;\n}\n\nvoid main(void) {\n\n  vec2 clrDomain \x3d colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);\n  vec4 color \x3d quantizeScale(clrDomain, colorRange, colors.r);\n\n  float elevation \x3d 0.0;\n\n  if (extruded) {\n    vec2 elvDomain \x3d elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);\n    elevation \x3d linearScale(elvDomain, elevationRange, elevations.r);\n    elevation \x3d elevation  * (positions.z + 1.0) / 2.0 * elevationScale;\n  }\n  float shouldRender \x3d float(color.r \x3e 0.0 \x26\x26 elevations.r \x3e\x3d 0.0);\n  float dotRadius \x3d cellSize / 2. * coverage * shouldRender;\n\n  int yIndex \x3d (gl_InstanceID / gridSize[0]);\n  int xIndex \x3d gl_InstanceID - (yIndex * gridSize[0]);\n\n  vec2 instancePositionXFP64 \x3d mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));\n  instancePositionXFP64 \x3d sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));\n  vec2 instancePositionYFP64 \x3d mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));\n  instancePositionYFP64 \x3d sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));\n\n  vec3 centroidPosition \x3d vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);\n  vec3 centroidPosition64Low \x3d vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);\n  vec3 pos \x3d vec3(project_size(positions.xy + offset) * dotRadius, 0.);\n  picking_setPickingColor(instancePickingColors);\n\n  vec4 position_commonspace;\n  gl_Position \x3d project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, position_commonspace);\n\n  vec3 normals_commonspace \x3d project_normal(normals);\n\n   if (extruded) {\n    vec3 lightColor \x3d lighting_getLightColor(color.rgb, project_uCameraPosition, position_commonspace.xyz, normals_commonspace);\n    vColor \x3d vec4(lightColor, color.a * opacity) / 255.;\n  } else {\n    vColor \x3d vec4(color.rgb, color.a * opacity) / 255.;\n  }\n}\n"}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$aggregation_layers$dist$es5$gpu_grid_layer$gpu_grid_cell_layer_vertex_glsl.js.map
