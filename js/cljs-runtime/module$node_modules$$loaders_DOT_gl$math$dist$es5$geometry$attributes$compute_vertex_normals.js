shadow$provide.module$node_modules$$loaders_DOT_gl$math$dist$es5$geometry$attributes$compute_vertex_normals=function(global,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if("undefined"===typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},
e:function(_e){throw _e;},f:allowArrayLike}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=o[Symbol.iterator]()},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it["return"])it["return"]()}finally{if(didErr)throw err;}}}}function _unsupportedIterableToArray(o,
minLen){if(o){if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);"Object"===n&&o.constructor&&(n=o.constructor.name);if("Map"===n||"Set"===n)return Array.from(o);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
Object.defineProperty(exports,"__esModule",{value:!0});exports.computeVertexNormals=function(_ref){var mode=_ref.mode,indices=_ref.indices,attributes=_ref.attributes;(0,_assert["default"])((0,_modes.getPrimitiveModeType)(mode)===_constants.GL.TRIANGLES,"TRIANGLES required");_ref=(0,_getAttributeFromGeometry.getPositions)({mode,indices,attributes}).values;var normals=new Float32Array(_ref.length),vectorA=new _core.Vector3,vectorB=new _core.Vector3,vectorC=new _core.Vector3,vectorCB=new _core.Vector3,
vectorAB=new _core.Vector3;mode=_createForOfIteratorHelper((0,_primitiveIterator.makePrimitiveIterator)({mode,indices,attributes}));var _step;try{for(mode.s();!(_step=mode.n()).done;){var primitive=_step.value;vectorA.fromArray(_ref,3*primitive.i1);vectorB.fromArray(_ref,3*primitive.i2+3);vectorC.fromArray(_ref,3*primitive.i3+6);vectorCB.subVectors(vectorC,vectorB);vectorAB.subVectors(vectorA,vectorB);var normal=vectorCB.cross(vectorAB);normal.normalize();var primitiveIndex=primitive.primitiveIndex;
normals[9*primitiveIndex]=normal.x;normals[9*primitiveIndex+1]=normal.y;normals[9*primitiveIndex+2]=normal.z;normals[9*primitiveIndex+3]=normal.x;normals[9*primitiveIndex+4]=normal.y;normals[9*primitiveIndex+5]=normal.z;normals[9*primitiveIndex+6]=normal.x;normals[9*primitiveIndex+7]=normal.y;normals[9*primitiveIndex+8]=normal.z}}catch(err){mode.e(err)}finally{mode.f()}return normals};var _core=require("module$node_modules$$math_DOT_gl$core$dist$es5$index"),_constants=require("module$node_modules$$loaders_DOT_gl$math$dist$es5$geometry$constants"),
_assert=global(require("module$node_modules$$loaders_DOT_gl$math$dist$es5$geometry$utils$assert")),_primitiveIterator=require("module$node_modules$$loaders_DOT_gl$math$dist$es5$geometry$iterators$primitive_iterator"),_modes=require("module$node_modules$$loaders_DOT_gl$math$dist$es5$geometry$primitives$modes"),_getAttributeFromGeometry=require("module$node_modules$$loaders_DOT_gl$math$dist$es5$geometry$attributes$get_attribute_from_geometry")}
//# sourceMappingURL=module$node_modules$$loaders_DOT_gl$math$dist$es5$geometry$attributes$compute_vertex_normals.js.map
