shadow$provide.module$node_modules$$luma_DOT_gl$experimental$dist$es5$gpgpu$histopyramid$histopyramid_shaders=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.HISTOPYRAMID_BUILD_VS_UTILS="// Get current pixel indices for a given size\nvec2 histoPyramid_getPixelIndices(vec2 size) {\n  vec2 pixelOffset \x3d transform_getPixelSizeHalf(size);\n  vec2 pixelIndices \x3d transform_getPixelIndices(size, pixelOffset);\n  return pixelIndices;\n}\n\n// returns the top left texture coordiante corresponding to 2X2 block in higher level texture.\n// size: lower level texture size\n// scale: usually (2, 2)\n// offset: offset with-in 2X2 block of higher level texture\nvec2 histoPyramid_getTexCoord(vec2 size, vec2 scale, vec2 offset) {\n  // use actual (scaled) texture size to calcualte offset (multiplied by scale)\n  vec2 scaledSize \x3d size * scale;\n\n  // use minified texture size to find corresponding pixel index in out texture\n  vec2 pixelIndices \x3d histoPyramid_getPixelIndices(size);\n\n  // now scale the indices to point to correct 2X2 block\n  pixelIndices \x3d pixelIndices * scale;\n\n  // generate tex coordinate using actual size\n  vec2 texCoord \x3d pixelIndices / scaledSize;\n  vec2 inPixelOffset \x3d transform_getPixelSizeHalf(scaledSize);\n\n  return texCoord + (offset / scaledSize) + inPixelOffset;\n}\n\n// returns pixel value from higher level texture based on scale and offset\n// texSampler: higher level texture sampler\n// size: lower level texture size\n// scale: usually (2, 2)\n// offset: offset with-in 2X2 block of higher level texture\nvec4 histoPyramid_getInput(sampler2D texSampler, vec2 size, vec2 scale, vec2 offset) {\n  vec2 texCoord \x3d histoPyramid_getTexCoord(size, scale, offset);\n  vec4 textureColor \x3d texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
exports.HISTOPYRAMID_BUILD_VS="attribute vec4 inTexture;\nvarying vec4 outTexture;\n\nvoid main()\n{\n  vec2 size \x3d transform_uSize_outTexture;\n  vec2 scale \x3d vec2(2., 2.);\n  vec4 pixel \x3d histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 0));\n  vec4 rightPixel \x3d histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 0));\n  vec4 bottomPixel \x3d histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 1));\n  vec4 rightBottomPixel \x3d histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 1));\n  // outTexture \x3d pixel + rightPixel + bottomPixel + rightBottomPixel;\n  outTexture \x3d vec4(\n    pixel.r + pixel.g + pixel.b + pixel.a,\n    rightPixel.r + rightPixel.g + rightPixel.b + rightPixel.a,\n    bottomPixel.r + bottomPixel.g + bottomPixel.b + bottomPixel.a,\n    rightBottomPixel.r + rightBottomPixel.g + rightBottomPixel.b + rightBottomPixel.a\n  );\n}\n";
exports.HISTOPYRAMID_BASE_BUILD_VS="attribute vec4 inTexture;\nvarying vec4 outTexture;\nuniform int channel;\nuniform vec4 padingPixelValue;\n\nvoid main()\n{\n  vec2 size \x3d transform_uSize_outTexture;\n  // vec2 scale \x3d vec2(2., 2.);\n  vec2 scale \x3d transform_uSize_inTexture / transform_uSize_outTexture;\n\n  // Verify if reference to a input texture pixel is out of bounds, if so treat the pixel as (0, 0)\n  vec2 pixelIndices \x3d histoPyramid_getPixelIndices(size);\n  // now scale the indices padded size to point to correct 2X2 block\n  pixelIndices \x3d pixelIndices * vec2(2, 2);\n\n  vec2 baseLevelSize \x3d transform_uSize_inTexture;\n\n  // For all pixels outside of original texture size, return paddingPixelValue\n  bool xInside \x3d pixelIndices.x \x3c baseLevelSize.x;\n  bool yInside \x3d pixelIndices.y \x3c baseLevelSize.y;\n  bool xPlusOneInside \x3d pixelIndices.x + 1. \x3c baseLevelSize.x;\n  bool yPlusOneInside \x3d pixelIndices.y + 1. \x3c baseLevelSize.y;\n\n  vec4 pixel \x3d (xInside \x26\x26 yInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 0))\n    : padingPixelValue;\n\n  vec4 rightPixel \x3d (xPlusOneInside \x26\x26 yInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 0))\n    : padingPixelValue;\n\n  vec4 topPixel \x3d (xInside \x26\x26 yPlusOneInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 1))\n    : padingPixelValue;\n\n  vec4 rightTopPixel \x3d (xPlusOneInside \x26\x26 yPlusOneInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 1))\n    : padingPixelValue;\n\n  if (channel \x3d\x3d 0) {\n    outTexture \x3d vec4(pixel.r, rightPixel.r, topPixel.r, rightTopPixel.r);\n  }\n  if (channel \x3d\x3d 1) {\n    outTexture \x3d vec4(pixel.g, rightPixel.g, topPixel.g, rightTopPixel.g);\n  }\n  if (channel \x3d\x3d 2) {\n    outTexture \x3d vec4(pixel.b, rightPixel.b, topPixel.b, rightTopPixel.b);\n  }\n  if (channel \x3d\x3d 3) {\n    outTexture \x3d vec4(pixel.a, rightPixel.a, topPixel.a, rightTopPixel.a);\n  }\n}\n";
exports.HISTOPYRAMID_TRAVERSAL_UTILS="// Check 2X2 texture block to find relative index the given key index falls into\n// 2X2 block is represented by a single RGBA weight\nint histopyramid_traversal_findRangeIndex(float currentKey, vec4 weights, out float lowerBound) {\n  lowerBound \x3d 0.;\n  float higherBound \x3d 0.;\n  int relativeIndex \x3d 0;\n  for (int i \x3d 0; i \x3c 4; i++) {\n    higherBound \x3d lowerBound + weights[i];\n    relativeIndex \x3d i;\n    if (currentKey \x3e\x3d lowerBound \x26\x26 currentKey \x3c higherBound) {\n      break;\n    }\n    lowerBound \x3d higherBound;\n  }\n  return relativeIndex;\n}\n\n// Maps index in 2X2 block to texture coordiante\n// Assumes the traversal order of lower-left -\x3e lower-\x3eright -\x3e upper-left -\x3e upper-\x3eright\nvec2 histopyramid_traversal_mapIndexToCoord(int index) {\n  // relativeIndex -\x3e  relativeCoordiante\n  // 0 -\x3e (0, 0)\n  // 1 -\x3e (1, 0)\n  // 2 -\x3e (0, 1)\n  // 3 -\x3e (1, 1)\n  float relativeX \x3d mod(float(index), 2.);\n  float relativeY \x3d (index \x3e 1) ? 1. : 0.;\n  return vec2(relativeX, relativeY);\n}\n\n// Reads weight value from flat histopyramid\nvec4 histopyramid_traversal_getWeight(sampler2D flatPyramid, vec2 size, int level, int numLevels, vec2 offset) {\n  // horizontal offset in flat pyramid for current level\n  float xOffset \x3d pow(2., float(numLevels)) - pow(2., float(numLevels - level));\n  vec2 lowerLeft \x3d vec2(xOffset, 0.);\n  vec2 pixelIndices \x3d lowerLeft + offset;\n\n  vec2 pixelSizeHalf \x3d transform_getPixelSizeHalf(size);\n  vec2 coord \x3d pixelIndices / size + pixelSizeHalf;\n\n  return texture2D(flatPyramid, coord);\n}\n";
exports.HISTOPYRAMID_TRAVERSAL_VS="attribute float keyIndex;\nattribute vec4 flatPyramidTexture;\nvarying vec4 locationAndIndex;\nconst int MAX_LEVELS \x3d 12; // assuming max texture size of 4K\n\nuniform int numLevels;\n\nvoid main()\n{\n  vec2 p \x3d vec2(0., 0.);\n  float currentKey \x3d keyIndex;\n  // for(int level \x3d numLevels - 1; level \x3c\x3d 0; level--) {\n  for(int i \x3d 1; i \x3c\x3d MAX_LEVELS; i++) {\n    int level \x3d numLevels - i;\n    // #1. Get the current pixel values based on current level and current p\n    vec4 weights \x3d histopyramid_traversal_getWeight(transform_uSampler_flatPyramidTexture, transform_uSize_flatPyramidTexture, level, numLevels, p);\n\n    // #2. Check the all weights in current 2X2 (4 values in RGBA channels) and determine the relative coordinate\n    float lowerBound \x3d 0.;\n    int relativeIndex \x3d histopyramid_traversal_findRangeIndex(currentKey, weights, lowerBound);\n    vec2 relativeCoord \x3d histopyramid_traversal_mapIndexToCoord(relativeIndex);\n\n    //#3. Update P and key-index\n    p \x3d 2.0 * p + relativeCoord;\n    currentKey -\x3d lowerBound;\n    if (level \x3d\x3d 0) { break; } // Work around for const expression restriction on for loops\n  }\n  locationAndIndex \x3d vec4(p, currentKey, keyIndex);\n}\n"}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$experimental$dist$es5$gpgpu$histopyramid$histopyramid_shaders.js.map
