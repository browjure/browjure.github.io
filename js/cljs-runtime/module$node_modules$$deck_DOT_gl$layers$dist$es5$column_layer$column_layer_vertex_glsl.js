shadow$provide.module$node_modules$$deck_DOT_gl$layers$dist$es5$column_layer$column_layer_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="\n#define SHADER_NAME column-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute float instanceElevations;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute float instanceStrokeWidths;\n\nattribute vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nvarying vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition \x3d instancePositions;\n\n  vec4 color \x3d isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix \x3d mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation \x3d 0.0;\n  float strokeOffsetRatio \x3d 1.0;\n\n  if (extruded) {\n    elevation \x3d instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (isStroke) {\n    float widthPixels \x3d clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    strokeOffsetRatio -\x3d sign(positions.z) * project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n  }\n  float shouldRender \x3d float(color.a \x3e 0.0 \x26\x26 instanceElevations \x3e\x3d 0.0);\n  float dotRadius \x3d radius * coverage * shouldRender;\n\n  geometry.normal \x3d project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  geometry.pickingColor \x3d instancePickingColors;\n  vec3 centroidPosition \x3d vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low \x3d instancePositions64Low;\n  vec3 pos \x3d vec3(project_size(rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position \x3d project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded \x26\x26 !isStroke) {\n    vec3 lightColor \x3d lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor \x3d vec4(lightColor, color.a * opacity);\n  } else {\n    vColor \x3d vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n"}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$layers$dist$es5$column_layer$column_layer_vertex_glsl.js.map
