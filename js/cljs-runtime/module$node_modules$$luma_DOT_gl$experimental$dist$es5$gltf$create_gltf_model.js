shadow$provide.module$node_modules$$luma_DOT_gl$experimental$dist$es5$gltf$create_gltf_model=function(global,require,module,exports){function addVersionToShader(gl,source){return(0,_gltools.isWebGL2)(gl)?"#version 300 es\n".concat(source):source}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=function(gl,options){var id=options.id,drawMode=options.drawMode,vertexCount=options.vertexCount,attributes=
options.attributes,modelOptions=options.modelOptions;options=new _gltfMaterialParser["default"](gl,options);_webgl.log.info(4,"createGLTFModel defines: ",options.defines)();var managedResources=[];managedResources.push.apply(managedResources,(0,_toConsumableArray2["default"])(options.generatedTextures));managedResources.push.apply(managedResources,(0,_toConsumableArray2["default"])(Object.values(attributes).map(function(attribute){return attribute.buffer})));gl=new _modelNode["default"](gl,Object.assign({id,
drawMode,vertexCount,modules:[_shadertools.pbr],defines:options.defines,parameters:options.parameters,vs:addVersionToShader(gl,vs),fs:addVersionToShader(gl,fs),managedResources},modelOptions));gl.setProps({attributes});gl.setUniforms(options.uniforms);return gl};var _toConsumableArray2=global(require("module$node_modules$$babel$runtime$helpers$toConsumableArray")),_gltools=require("module$node_modules$$luma_DOT_gl$gltools$dist$es5$index"),_webgl=require("module$node_modules$$luma_DOT_gl$webgl$dist$es5$index"),
_shadertools=require("module$node_modules$$luma_DOT_gl$shadertools$dist$es5$index"),_modelNode=global(require("module$node_modules$$luma_DOT_gl$experimental$dist$es5$scenegraph$model_node")),_gltfMaterialParser=global(require("module$node_modules$$luma_DOT_gl$experimental$dist$es5$gltf$gltf_material_parser")),vs="\n#if (__VERSION__ \x3c 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL \x3d vec4(0.);\n    vec4 _TANGENT \x3d vec4(0.);\n    vec2 _TEXCOORD_0 \x3d vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL \x3d NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT \x3d TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 \x3d TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position \x3d u_MVPMatrix * POSITION;\n  }\n",
fs="\n#if (__VERSION__ \x3c 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor \x3d pbr_filterColor(vec4(0));\n  }\n"}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$experimental$dist$es5$gltf$create_gltf_model.js.map
