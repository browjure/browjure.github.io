shadow$provide.module$node_modules$$deck_DOT_gl$layers$dist$es5$geojson_layer$geojson=function(global,require,module,exports){function separateGeometry(geometry,separated,wrapFeature,sourceFeature,sourceFeatureIndex){var type=geometry.type,coordinates=geometry.coordinates,pointFeatures=separated.pointFeatures,lineFeatures=separated.lineFeatures,polygonFeatures=separated.polygonFeatures,polygonOutlineFeatures=separated.polygonOutlineFeatures;if(validateGeometry(type,coordinates))switch(type){case "Point":pointFeatures.push(wrapFeature({geometry},
sourceFeature,sourceFeatureIndex));break;case "MultiPoint":coordinates.forEach(function(point){pointFeatures.push(wrapFeature({geometry:{type:"Point",coordinates:point}},sourceFeature,sourceFeatureIndex))});break;case "LineString":lineFeatures.push(wrapFeature({geometry},sourceFeature,sourceFeatureIndex));break;case "MultiLineString":coordinates.forEach(function(path){lineFeatures.push(wrapFeature({geometry:{type:"LineString",coordinates:path}},sourceFeature,sourceFeatureIndex))});break;case "Polygon":polygonFeatures.push(wrapFeature({geometry},
sourceFeature,sourceFeatureIndex));coordinates.forEach(function(path){polygonOutlineFeatures.push(wrapFeature({geometry:{type:"LineString",coordinates:path}},sourceFeature,sourceFeatureIndex))});break;case "MultiPolygon":coordinates.forEach(function(polygon){polygonFeatures.push(wrapFeature({geometry:{type:"Polygon",coordinates:polygon}},sourceFeature,sourceFeatureIndex));polygon.forEach(function(path){polygonOutlineFeatures.push(wrapFeature({geometry:{type:"LineString",coordinates:path}},sourceFeature,
sourceFeatureIndex))})})}else _core.log.warn("".concat(type," coordinates are malformed"))()}function validateGeometry(type,coordinates){var nestLevel=COORDINATE_NEST_LEVEL[type];for(_core.log.assert(nestLevel,"Unknown GeoJSON type ".concat(type));coordinates&&0<--nestLevel;)coordinates=coordinates[0];return coordinates&&Number.isFinite(coordinates[0])}Object.defineProperty(exports,"__esModule",{value:!0});exports.getGeojsonFeatures=function(geojson){if(Array.isArray(geojson))return geojson;_core.log.assert(geojson.type,
"GeoJSON does not have type");switch(geojson.type){case "Feature":return[geojson];case "FeatureCollection":return _core.log.assert(Array.isArray(geojson.features),"GeoJSON does not have features array"),geojson.features;default:return[{geometry:geojson}]}};exports.separateGeojsonFeatures=function(features,wrapFeature){var dataRange=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},separated={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},_dataRange$startRow=
dataRange.startRow;dataRange=dataRange.endRow;dataRange=void 0===dataRange?features.length:dataRange;for(_dataRange$startRow=void 0===_dataRange$startRow?0:_dataRange$startRow;_dataRange$startRow<dataRange;_dataRange$startRow++){var feature=features[_dataRange$startRow];_core.log.assert(feature&&feature.geometry,"GeoJSON does not have geometry");var geometry=feature.geometry;if("GeometryCollection"===geometry.type){_core.log.assert(Array.isArray(geometry.geometries),"GeoJSON does not have geometries array");
geometry=geometry.geometries;for(var i=0;i<geometry.length;i++)separateGeometry(geometry[i],separated,wrapFeature,feature,_dataRange$startRow)}else separateGeometry(geometry,separated,wrapFeature,feature,_dataRange$startRow)}return separated};exports.validateGeometry=validateGeometry;var _core=require("module$node_modules$$deck_DOT_gl$core$dist$es5$index"),COORDINATE_NEST_LEVEL={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4}}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$layers$dist$es5$geojson_layer$geojson.js.map
