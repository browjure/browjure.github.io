shadow$provide.module$node_modules$$deck_DOT_gl$core$dist$es5$utils$tesselator=function(global,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if("undefined"===typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},e:function(_e){throw _e;
},f:allowArrayLike}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=o[Symbol.iterator]()},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it["return"])it["return"]()}finally{if(didErr)throw err;}}}}function _unsupportedIterableToArray(o,
minLen){if(o){if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);"Object"===n&&o.constructor&&(n=o.constructor.name);if("Map"===n||"Set"===n)return Array.from(o);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;var _classCallCheck2=global(require("module$node_modules$$babel$runtime$helpers$classCallCheck")),_createClass2=global(require("module$node_modules$$babel$runtime$helpers$createClass")),_iterableUtils=require("module$node_modules$$deck_DOT_gl$core$dist$es5$utils$iterable_utils"),_typedArrayManager=global(require("module$node_modules$$deck_DOT_gl$core$dist$es5$utils$typed_array_manager")),_assert=global(require("module$node_modules$$deck_DOT_gl$core$dist$es5$utils$assert")),
_core=require("module$node_modules$$luma_DOT_gl$core$dist$es5$index");require=function(){function Tesselator(){var opts=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};(0,_classCallCheck2["default"])(this,Tesselator);var _opts$attributes=opts.attributes;_opts$attributes=void 0===_opts$attributes?{}:_opts$attributes;this.typedArrayManager=_typedArrayManager["default"];this.vertexStarts=this.indexStarts=null;this.instanceCount=this.vertexCount=0;this.attributes={};this._attributeDefs=_opts$attributes;
this.opts=opts;this.updateGeometry(opts);Object.seal(this)}(0,_createClass2["default"])(Tesselator,[{key:"updateGeometry",value:function(opts){Object.assign(this.opts,opts);var _this$opts=this.opts;opts=_this$opts.data;var _this$opts$buffers=_this$opts.buffers;_this$opts$buffers=void 0===_this$opts$buffers?{}:_this$opts$buffers;var getGeometry=_this$opts.getGeometry,geometryBuffer=_this$opts.geometryBuffer,positionFormat=_this$opts.positionFormat,dataChanged=_this$opts.dataChanged;_this$opts=_this$opts.normalize;
_this$opts=void 0===_this$opts?!0:_this$opts;this.data=opts;this.getGeometry=getGeometry;this.positionSize=geometryBuffer&&geometryBuffer.size||("XY"===positionFormat?2:3);this.buffers=_this$opts$buffers;this.normalize=_this$opts;geometryBuffer&&((0,_assert["default"])(opts.startIndices,"binary data missing startIndices"),this.getGeometry=this.getGeometryFromBuffer(geometryBuffer),_this$opts||(_this$opts$buffers.positions=geometryBuffer));this.geometryBuffer=_this$opts$buffers.positions;if(Array.isArray(dataChanged)){opts=
_createForOfIteratorHelper(dataChanged);var _step;try{for(opts.s();!(_step=opts.n()).done;)this._rebuildGeometry(_step.value)}catch(err){opts.e(err)}finally{opts.f()}}else this._rebuildGeometry()}},{key:"updatePartialGeometry",value:function(_ref){this._rebuildGeometry({startRow:_ref.startRow,endRow:_ref.endRow})}},{key:"normalizeGeometry",value:function(geometry){return geometry}},{key:"updateGeometryAttributes",value:function(geometry,startIndex,size){throw Error("Not implemented");}},{key:"getGeometrySize",
value:function(geometry){throw Error("Not implemented");}},{key:"getGeometryFromBuffer",value:function(geometryBuffer){var value=geometryBuffer.value||geometryBuffer;(0,_assert["default"])(ArrayBuffer.isView(value),"cannot read geometries");return(0,_iterableUtils.getAccessorFromBuffer)(value,{size:this.positionSize,offset:geometryBuffer.offset,stride:geometryBuffer.stride,startIndices:this.data.startIndices})}},{key:"_allocate",value:function(instanceCount,copy){var attributes=this.attributes,buffers=
this.buffers,_attributeDefs=this._attributeDefs,typedArrayManager=this.typedArrayManager,name;for(name in _attributeDefs)if(name in buffers)typedArrayManager.release(attributes[name]),attributes[name]=null;else{var def=_attributeDefs[name];def.copy=copy;attributes[name]=typedArrayManager.allocate(attributes[name],instanceCount,def)}}},{key:"_forEachGeometry",value:function(visitor,startRow,endRow){var data=this.data,getGeometry=this.getGeometry;endRow=(0,_iterableUtils.createIterable)(data,startRow,
endRow);startRow=endRow.objectInfo;endRow=_createForOfIteratorHelper(endRow.iterable);var _step2;try{for(endRow.s();!(_step2=endRow.n()).done;){var object=_step2.value;startRow.index++;var geometry=getGeometry(object,startRow);visitor(geometry,startRow.index)}}catch(err){endRow.e(err)}finally{endRow.f()}}},{key:"_rebuildGeometry",value:function(dataRange){var _this=this;if(this.data&&this.getGeometry){var indexStarts=this.indexStarts,vertexStarts=this.vertexStarts,instanceCount=this.instanceCount,
data=this.data,geometryBuffer=this.geometryBuffer,_ref2=dataRange||{},_ref2$startRow=_ref2.startRow;_ref2$startRow=void 0===_ref2$startRow?0:_ref2$startRow;_ref2=_ref2.endRow;_ref2=void 0===_ref2?Infinity:_ref2;var normalizedData={};dataRange||(indexStarts=[0],vertexStarts=[0]);if(this.normalize||!geometryBuffer)this._forEachGeometry(function(geometry,dataIndex){geometry=_this.normalizeGeometry(geometry);normalizedData[dataIndex]=geometry;vertexStarts[dataIndex+1]=vertexStarts[dataIndex]+_this.getGeometrySize(geometry)},
_ref2$startRow,_ref2),instanceCount=vertexStarts[vertexStarts.length-1];else if(geometryBuffer.buffer instanceof _core.Buffer){var byteStride=geometryBuffer.stride||4*this.positionSize;vertexStarts=data.startIndices;instanceCount=vertexStarts[data.length]||geometryBuffer.buffer.byteLength/byteStride}else byteStride=geometryBuffer.value||geometryBuffer,geometryBuffer=geometryBuffer.stride/byteStride.BYTES_PER_ELEMENT||this.positionSize,vertexStarts=data.startIndices,instanceCount=vertexStarts[data.length]||
byteStride.length/geometryBuffer;this._allocate(instanceCount,!!dataRange);this.indexStarts=indexStarts;this.vertexStarts=vertexStarts;this.instanceCount=instanceCount;var context={};this._forEachGeometry(function(geometry,dataIndex){geometry=normalizedData[dataIndex]||geometry;context.vertexStart=vertexStarts[dataIndex];context.indexStart=indexStarts[dataIndex];context.geometrySize=(dataIndex<vertexStarts.length-1?vertexStarts[dataIndex+1]:instanceCount)-vertexStarts[dataIndex];context.geometryIndex=
dataIndex;_this.updateGeometryAttributes(geometry,context)},_ref2$startRow,_ref2);this.vertexCount=indexStarts[indexStarts.length-1]}}}]);return Tesselator}();exports["default"]=require}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$core$dist$es5$utils$tesselator.js.map
