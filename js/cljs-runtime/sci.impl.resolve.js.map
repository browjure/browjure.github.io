{"version":3,"sources":["sci/impl/resolve.cljc"],"mappings":"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","names":["sci.impl.resolve/throw-error-with-location","msg","node","sci.impl.utils.throw_error_with_location","sci.impl.resolve/mark-resolve-sym","sym","cljs.core.vary_meta","m","cljs.core.assoc","p__66496","map__66497","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","allow","cljs.core.get","deny","sci.impl.resolve/check-permission!","check-sym","v","or__4126__auto__","sci.impl.utils/allowed-loop","sci.impl.utils/allowed-recur","sci.impl.utils/strip-core-ns","sci.impl.vars/var?","cljs.core/not","cljs.core/meta","cljs.core/contains?","sci.impl.resolve/lookup*","ctx","call?","cljs.core/deref","sym-ns","G__66549","cljs.core/namespace","cljs.core.symbol","sym-name","cljs.core/name","env","cnn","sci.impl.vars/current-ns-name","the-current-ns","G__66553","cljs.core.get_in","cljs.core._EQ_","G__66571","cljs.core/find","temp__5753__auto__","sci.impl.utils/ana-macros","G__66582","clazz","sci.impl.interop/resolve-class","cljs.core/with-meta","refers","kv","G__66600","G__66604","c","x","sci.impl.records.resolve_record_or_protocol_class","sci.impl.resolve/tag","_ctx","expr","sci.impl.resolve/lookup","vec__66625","cljs.core.nth","bindings","k","vec__66635","t","cljs.core/assoc","sci.impl.utils/ctx-fn","vec__66641","temp__5751__auto__","cljs.core/vreset!","sci.impl.utils/lookup","var_args","G__66651","sci.impl.resolve/resolve-symbol","js/Error","sci.impl.resolve.resolve_symbol","res","cljs.core/second","n","and__4115__auto__","clojure.string/starts-with?","clojure.string/ends-with?","cljs.core.subs"],"sourcesContent":["(ns sci.impl.resolve\n  {:no-doc true}\n  (:require [clojure.string :as str]\n            [sci.impl.evaluator :as eval]\n            [sci.impl.faster :as faster]\n            [sci.impl.interop :as interop]\n            [sci.impl.records :as records]\n            [sci.impl.utils :as utils :refer [strip-core-ns\n                                              ana-macros\n                                              ctx-fn]]\n            [sci.impl.vars :as vars]))\n\n(defn throw-error-with-location [msg node]\n  (utils/throw-error-with-location msg node {:phase \"analysis\"}))\n\n(defn mark-resolve-sym\n  [sym]\n  (vary-meta\n   sym\n   (fn [m]\n     (assoc m :sci.impl/op :resolve-sym))))\n\n(defn check-permission! [{:keys [:allow :deny]} check-sym sym v]\n  (or (identical? utils/allowed-loop sym)\n      (identical? utils/allowed-recur sym)\n      (let [check-sym (strip-core-ns check-sym)]\n        (when-not (if allow (or (and (vars/var? v) (not (:sci.impl/built-in (meta v))))\n                                (contains? allow check-sym))\n                      true)\n          (throw-error-with-location (str sym \" is not allowed!\") sym))\n        (when (if deny (contains? deny check-sym)\n                  false)\n          (throw-error-with-location (str sym \" is not allowed!\") sym)))))\n\n(defn lookup* [ctx sym call?]\n  (let [sym-ns (some-> (namespace sym) symbol)\n        sym-name (symbol (name sym))\n        env (faster/get-2 ctx :env)\n        env @env\n        cnn (vars/current-ns-name)\n        the-current-ns (-> env :namespaces cnn)\n        ;; resolve alias\n        sym-ns (when sym-ns (or (get-in the-current-ns [:aliases sym-ns])\n                                sym-ns))]\n    (if sym-ns\n      (or\n       (when (or (= sym-ns 'clojure.core) (= sym-ns 'cljs.core))\n         (or (some-> env :namespaces (get 'clojure.core) (find sym-name))\n             (when-let [v (when call? (get ana-macros sym-name))]\n               [sym v])))\n       (or (some-> env :namespaces sym-ns (find sym-name))\n           (when-let [clazz (interop/resolve-class ctx sym-ns)]\n             [sym (with-meta\n                    [clazz sym-name]\n                    #?(:clj\n                       (if call?\n                         {:sci.impl.analyzer/static-access true}\n                         {:sci.impl/op :static-access\n                          :file @vars/current-file\n                          :ns @vars/current-ns})\n                       :cljs {:sci.impl/op :static-access}))])))\n      ;; no sym-ns\n      (or\n       ;; prioritize refers over vars in the current namespace, see 527\n       (when-let [refers (:refers the-current-ns)]\n         (find refers sym-name))\n       (find the-current-ns sym) ;; env can contain foo/bar symbols from bindings\n       (let [kv (some-> env :namespaces (get 'clojure.core) (find sym-name))]\n         ;; only valid when the symbol isn't excluded\n         (when-not (some-> the-current-ns\n                           :refer\n                           (get 'clojure.core)\n                           :exclude\n                           (contains? sym-name))\n           kv))\n       (when (when call? (get ana-macros sym))\n         [sym sym])\n       (when-let [c (interop/resolve-class ctx sym)]\n         [sym c])\n       ;; resolves record or protocol referenced as class\n       ;; e.g. clojure.lang.IDeref which is really a var in clojure.lang/IDeref\n       (when-let [x (records/resolve-record-or-protocol-class ctx sym)]\n         [sym x])))))\n\n(defn tag [_ctx expr]\n  (when-let [m (meta expr)]\n    (:tag m)))\n\n(defn lookup [ctx sym call?]\n  (let [bindings (faster/get-2 ctx :bindings)\n        [k v :as kv]\n        (or\n         ;; bindings are not checked for permissions\n         (when-let [[k v]\n                    (find bindings sym)]\n           ;; never inline a binding at macro time!\n           (let [t (tag ctx v)\n                 v (mark-resolve-sym k)\n                 ;; pass along tag of expression!\n                 v (if t\n                     ;; when v has a tag, let's handle it the old way for now\n                     (vary-meta v assoc :tag t)\n                     (if call? ;; resolve-symbol is already handled in the call case\n                       v\n                       (ctx-fn\n                        (fn [ctx]\n                          (eval/resolve-symbol ctx v))\n                        v)))]\n             [k v]))\n         (when-let\n             [[k v :as kv]\n              (lookup* ctx sym call?)]\n           (check-permission! ctx k sym v)\n           kv))]\n    ;; (prn 'lookup sym '-> res)\n    (if-let [m (and (not (:sci.impl/prevent-deref ctx))\n                    (meta k))]\n      (if (:sci.impl/deref! m)\n        ;; the evaluation of this expression has been delayed by\n        ;; the caller and now is the time to deref it\n        [k (with-meta [v]\n             {:sci.impl/op :deref!})]\n        kv)\n      kv)))\n\n;; workaround for evaluator also needing this function\n(vreset! utils/lookup lookup)\n\n(defn resolve-symbol\n  ([ctx sym] (resolve-symbol ctx sym false))\n  ([ctx sym call?]\n   (let [sym sym ;; (strip-core-ns sym)\n         res (second\n              (or\n               (lookup ctx sym call?)\n               ;; TODO: check if symbol is in macros and then emit an error: cannot take\n               ;; the value of a macro\n               (let [n (name sym)]\n                 (cond\n                   (and call?\n                        (str/starts-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-dot*] ;; method invocation\n                   (and call?\n                        (str/ends-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-constructor]\n                   (str/starts-with? n \"'\") ;; TODO: deprecated?\n                   (let [v (symbol (subs n 1))]\n                     [v v])\n                   :else\n                   (throw-error-with-location\n                    (str \"Could not resolve symbol: \" (str sym))\n                    sym)))))]\n     ;; (prn 'resolve sym '-> res (meta res))\n     res)))\n"]}