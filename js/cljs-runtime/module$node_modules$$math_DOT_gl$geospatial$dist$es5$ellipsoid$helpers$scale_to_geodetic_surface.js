shadow$provide.module$node_modules$$math_DOT_gl$geospatial$dist$es5$ellipsoid$helpers$scale_to_geodetic_surface=function(global,require,module,exports){global=require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=function(cartesian,ellipsoid){var result=2<arguments.length&&void 0!==arguments[2]?arguments[2]:new _core.Vector3,oneOverRadii=ellipsoid.oneOverRadii,oneOverRadiiSquared=ellipsoid.oneOverRadiiSquared,
centerToleranceSquared=ellipsoid.centerToleranceSquared;scratchVector.from(cartesian);var positionX=cartesian.x,positionY=cartesian.y,positionZ=cartesian.z,oneOverRadiiX=oneOverRadii.x,oneOverRadiiY=oneOverRadii.y;oneOverRadii=oneOverRadii.z;positionX=positionX*positionX*oneOverRadiiX*oneOverRadiiX;positionY=positionY*positionY*oneOverRadiiY*oneOverRadiiY;positionZ=positionZ*positionZ*oneOverRadii*oneOverRadii;oneOverRadiiY=positionX+positionY+positionZ;oneOverRadii=Math.sqrt(1/oneOverRadiiY);if(Number.isFinite(oneOverRadii)){oneOverRadiiX=
scaleToGeodeticSurfaceIntersection;oneOverRadiiX.copy(cartesian).scale(oneOverRadii);if(oneOverRadiiY<centerToleranceSquared)return oneOverRadiiX.to(result);centerToleranceSquared=oneOverRadiiSquared.x;oneOverRadiiY=oneOverRadiiSquared.y;oneOverRadiiSquared=oneOverRadiiSquared.z;var gradient=scaleToGeodeticSurfaceGradient;gradient.set(oneOverRadiiX.x*centerToleranceSquared*2,oneOverRadiiX.y*oneOverRadiiY*2,oneOverRadiiX.z*oneOverRadiiSquared*2);oneOverRadii=(1-oneOverRadii)*cartesian.len()/(.5*gradient.len());
var correction=0;do{oneOverRadii-=correction;oneOverRadiiX=1/(1+oneOverRadii*centerToleranceSquared);gradient=1/(1+oneOverRadii*oneOverRadiiY);var zMultiplier=1/(1+oneOverRadii*oneOverRadiiSquared);var func=oneOverRadiiX*oneOverRadiiX;var yMultiplier2=gradient*gradient,zMultiplier2=zMultiplier*zMultiplier;correction=func*oneOverRadiiX;var yMultiplier3=yMultiplier2*gradient,zMultiplier3=zMultiplier2*zMultiplier;func=positionX*func+positionY*yMultiplier2+positionZ*zMultiplier2-1;correction=func/(-2*
(positionX*correction*centerToleranceSquared+positionY*yMultiplier3*oneOverRadiiY+positionZ*zMultiplier3*oneOverRadiiSquared))}while(Math.abs(func)>_core._MathUtils.EPSILON12);return scratchVector.scale([oneOverRadiiX,gradient,zMultiplier]).to(result)}};var _core=require("module$node_modules$$math_DOT_gl$core$dist$es5$index");global(require("module$node_modules$gl_matrix$cjs$vec3"));var scratchVector=new _core.Vector3,scaleToGeodeticSurfaceIntersection=new _core.Vector3,scaleToGeodeticSurfaceGradient=
new _core.Vector3}
//# sourceMappingURL=module$node_modules$$math_DOT_gl$geospatial$dist$es5$ellipsoid$helpers$scale_to_geodetic_surface.js.map
