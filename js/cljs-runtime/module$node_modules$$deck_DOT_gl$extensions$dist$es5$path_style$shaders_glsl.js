shadow$provide.module$node_modules$$deck_DOT_gl$extensions$dist$es5$path_style$shaders_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.dashShaders={inject:{"vs:#decl":"\nattribute vec2 instanceDashArrays;\nattribute float instanceDashOffsets;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n","vs:#main-end":"\nvDashArray \x3d instanceDashArrays;\nvDashOffset \x3d instanceDashOffsets / width.x;\n","fs:#decl":"\nuniform float dashAlignMode;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n",
"fs:#main-start":"\n  float solidLength \x3d vDashArray.x;\n  float gapLength \x3d vDashArray.y;\n  float unitLength \x3d solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength \x3e 0.0) {\n    if (dashAlignMode \x3d\x3d 0.0) {\n      offset \x3d vDashOffset;\n    } else {\n      unitLength \x3d vPathLength / round(vPathLength / unitLength);\n      offset \x3d solidLength / 2.0;\n    }\n\n    if (\n      gapLength \x3e 0.0 \x26\x26\n      mod(clamp(vPathPosition.y, 0.0, vPathLength) + offset, unitLength) \x3e solidLength\n    ) {\n      discard;\n    }\n  }\n"}};
exports.offsetShaders={inject:{"vs:#decl":"\nattribute float instanceOffsets;\n","vs:DECKGL_FILTER_SIZE":"\n  float offsetWidth \x3d abs(instanceOffsets * 2.0) + 1.0;\n  size *\x3d offsetWidth;\n","vCornerOffset \x3d offsetVec;":"\n  float offsetWidth \x3d abs(instanceOffsets * 2.0) + 1.0;\n  vec2 offsetCenter \x3d -instanceOffsets * (isCap ? perp : miterVec * miterSize) * 2.0;\n  vCornerOffset \x3d vCornerOffset * offsetWidth - offsetCenter;\n","fs:#main-start":"\n  float isInside;\n  isInside \x3d step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside \x3d\x3d 0.0) {\n    discard;\n  }\n"}}}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$extensions$dist$es5$path_style$shaders_glsl.js.map
