shadow$provide.module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$pbr$pbr_fragment_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="#if defined(USE_TEX_LOD) \x26\x26 !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) \x26\x26 !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ \x3c 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI \x3d 3.141592653589793;\nconst float c_MinRoughness \x3d 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut \x3d pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess \x3d step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut \x3d mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx \x3d dFdx(pbr_vPosition);\n  vec3 pos_dy \x3d dFdy(pbr_vPosition);\n  vec3 tex_dx \x3d dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy \x3d dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t \x3d (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng \x3d normalize(pbr_vNormal);\n#else\n  vec3 ng \x3d cross(pos_dx, pos_dy);\n#endif\n\n  t \x3d normalize(t - ng * dot(ng, t));\n  vec3 b \x3d normalize(cross(ng, t));\n  mat3 tbn \x3d mat3(t, b, ng);\n#else\n  mat3 tbn \x3d pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n \x3d texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n \x3d normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n \x3d normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount \x3d 9.0;\n  float lod \x3d (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf \x3d SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight \x3d SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight \x3d SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight \x3d SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse \x3d diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular \x3d specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *\x3d u_ScaleIBLAmbient.x;\n  specular *\x3d u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL \x3d pbrInputs.NdotL;\n  float NdotV \x3d pbrInputs.NdotV;\n  float r \x3d pbrInputs.alphaRoughness;\n\n  float attenuationL \x3d 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV \x3d 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq \x3d pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f \x3d (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL \x3d 1.0;\n  pbrInputs.NdotH \x3d 0.0;\n  pbrInputs.LdotH \x3d 0.0;\n  pbrInputs.VdotH \x3d 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n \x3d pbrInputs.n;\n  vec3 v \x3d pbrInputs.v;\n  vec3 l \x3d normalize(lightDirection);\n  vec3 h \x3d normalize(l+v);\n\n  pbrInputs.NdotL \x3d clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH \x3d clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH \x3d clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH \x3d clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction \x3d normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F \x3d specularReflection(pbrInputs);\n  float G \x3d geometricOcclusion(pbrInputs);\n  float D \x3d microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib \x3d (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib \x3d F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor \x3d SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor \x3d u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a \x3c u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color \x3d vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb \x3d baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness \x3d u_MetallicRoughnessValues.y;\n    float metallic \x3d u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample \x3d texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness \x3d mrSample.g * perceptualRoughness;\n    metallic \x3d mrSample.b * metallic;\n#endif\n    perceptualRoughness \x3d clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic \x3d clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness \x3d perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 \x3d vec3(0.04);\n    vec3 diffuseColor \x3d baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *\x3d 1.0 - metallic;\n    vec3 specularColor \x3d mix(f0, baseColor.rgb, metallic);\n    float reflectance \x3d max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 \x3d clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 \x3d specularColor.rgb;\n    vec3 specularEnvironmentR90 \x3d vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n \x3d getNormal();\n    vec3 v \x3d normalize(u_Camera - pbr_vPosition);\n\n    float NdotV \x3d clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection \x3d -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs \x3d PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color +\x3d calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i \x3d 0, i \x3c MAX_LIGHTS, i \x3c lighting_uDirectionalLightCount, i++) {\n      if (i \x3c lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color +\x3d calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i \x3d 0, i \x3c MAX_LIGHTS, i \x3c lighting_uPointLightCount, i++) {\n      if (i \x3c lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation \x3d getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color +\x3d calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color +\x3d getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao \x3d texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color \x3d mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive \x3d SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color +\x3d emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color \x3d mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color \x3d mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color \x3d mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n"}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$pbr$pbr_fragment_glsl.js.map
