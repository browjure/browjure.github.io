shadow$provide.module$node_modules$$deck_DOT_gl$layers$dist$es5$path_layer$path_layer_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON \x3d 0.001;\nconst vec3 ZERO_OFFSET \x3d vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd \x3d positions.x \x3e 0.0;\n  float sideOfPath \x3d positions.y;\n  float isJoint \x3d float(sideOfPath \x3d\x3d 0.0);\n\n  vec3 deltaA3 \x3d (currPoint - prevPoint);\n  vec3 deltaB3 \x3d (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation \x3d !billboard \x26\x26 project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 \x3d deltaA3 * rotationMatrix;\n    deltaB3 \x3d deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA \x3d deltaA3.xy / width;\n  vec2 deltaB \x3d deltaB3.xy / width;\n\n  float lenA \x3d length(deltaA);\n  float lenB \x3d length(deltaB);\n\n  vec2 dirA \x3d lenA \x3e 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB \x3d lenB \x3e 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA \x3d vec2(-dirA.y, dirA.x);\n  vec2 perpB \x3d vec2(-dirB.y, dirB.x);\n  vec2 tangent \x3d dirA + dirB;\n  tangent \x3d length(tangent) \x3e 0. ? normalize(tangent) : perpA;\n  vec2 miterVec \x3d vec2(-tangent.y, tangent.x);\n  vec2 dir \x3d isEnd ? dirA : dirB;\n  vec2 perp \x3d isEnd ? perpA : perpB;\n  float L \x3d isEnd ? lenA : lenB;\n  float sinHalfA \x3d abs(dot(miterVec, perp));\n  float cosHalfA \x3d abs(dot(dirA, miterVec));\n  float turnDirection \x3d flipIfTrue(dirA.x * dirB.y \x3e\x3d dirA.y * dirB.x);\n  float cornerPosition \x3d sideOfPath * turnDirection;\n\n  float miterSize \x3d 1.0 / max(sinHalfA, EPSILON);\n  miterSize \x3d mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec \x3d mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap \x3d lenA \x3d\x3d 0.0 || (!isEnd \x26\x26 (instanceTypes \x3d\x3d 1.0 || instanceTypes \x3d\x3d 3.0));\n  bool isEndCap \x3d lenB \x3d\x3d 0.0 || (isEnd \x26\x26 (instanceTypes \x3d\x3d 2.0 || instanceTypes \x3d\x3d 3.0));\n  bool isCap \x3d isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec \x3d mix(perp * sideOfPath, dir * jointType * 4.0 * flipIfTrue(isStartCap), isJoint);\n  }\n  vPathLength \x3d L;\n  vCornerOffset \x3d offsetVec;\n  vMiterLength \x3d dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength \x3d isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath \x3d vCornerOffset + deltaA * float(isEnd);\n  vPathPosition \x3d vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv \x3d vPathPosition;\n\n  float isValid \x3d step(instanceTypes, 3.5);\n  vec3 offset \x3d vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset \x3d rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w \x3c EPSILON) {\n    float r \x3d (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position \x3d refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.worldPosition \x3d instanceStartPositions;\n  geometry.worldPositionAlt \x3d instanceEndPositions;\n  geometry.pickingColor \x3d instancePickingColors;\n\n  vec2 widthPixels \x3d vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  vColor \x3d vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd \x3d positions.x;\n\n  vec3 prevPosition \x3d mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low \x3d mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition \x3d mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low \x3d mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition \x3d mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low \x3d mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen \x3d project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen \x3d project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen \x3d project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width \x3d vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos \x3d lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position \x3d vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition \x3d project_position(prevPosition, prevPosition64Low);\n    currPosition \x3d project_position(currPosition, currPosition64Low);\n    nextPosition \x3d project_position(nextPosition, nextPosition64Low);\n\n    width \x3d vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos \x3d vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position \x3d pos;\n    gl_Position \x3d project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n"}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$layers$dist$es5$path_layer$path_layer_vertex_glsl.js.map
