{"version":3,"sources":["sci/impl/parser.cljc"],"mappings":"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","names":["sci.impl.parser/eof","sci.impl.parser/default-opts","edamame.impl.parser/normalize-opts","obj","cljs.core/Symbol","cljs.core/seq?","sci.impl.parser/var->sym","v","temp__5753__auto__","m","cljs.core/meta","var-name","ns","cljs.core.symbol","sci.impl.vars/getName","sci.impl.parser/fully-qualify","ctx","sym","cljs.core/deref","env","sym-ns","n","cljs.core/namespace","sym-name-str","cljs.core/name","current-ns","sci.impl.vars/current-ns-name","current-ns-str","namespaces","cljs.core.get","the-current-ns","aliases","ret","cljs.core/not","or__4126__auto__","refers","cljs.core/contains?","G__73237","sci.impl.utils/ana-macros","sci.impl.interop/fully-qualify-class","cljs.core.get_in","temp__5751__auto__","var_args","G__73248","sci.impl.parser/parse-next","js/Error","r","sci.impl.parser.parse_next","opts","features","readers","sci.impl.vars/var?","env-val","auto-resolve","cljs.core.assoc","parse-opts","G__73259","p1__73245#","cljs.core.merge","e73265","edamame.impl.parser.parse_next","sci.impl.utils/kw-identical?","cljs.core/ExceptionInfo","e","cljs.core.ex_info","cljs.core/ex-data","sci.impl.vars/current-file","sci.impl.parser/reader","x","string-reader","cljs.tools.reader.reader-types/string-reader","buf-len","pushback-reader","cljs.tools.reader.reader-types/PushbackReader","cljs.core.object_array","cljs.tools.reader.reader_types.indexing_push_back_reader","sci.impl.parser/get-line-number","reader","cljs.tools.reader.reader-types/get-line-number","sci.impl.parser/get-column-number","cljs.tools.reader.reader-types/get-column-number","sci.impl.parser/parse-string","s"],"sourcesContent":["(ns sci.impl.parser\n  {:no-doc true}\n  (:refer-clojure :exclude [read-string])\n  (:require\n   [clojure.tools.reader.reader-types :as r]\n   [edamame.impl.parser :as edamame]\n   [sci.impl.interop :as interop]\n   [sci.impl.utils :as utils]\n   [sci.impl.vars :as vars]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(def ^:const eof :sci.impl.parser.edamame/eof)\n\n(def default-opts\n  (edamame/normalize-opts\n   {:all true\n    :read-eval false\n    :row-key :line\n    :col-key :column\n    :read-cond :allow\n    :location? (fn [obj]\n                 (or\n                  ;; for fine-grained error messages during analysis we also add\n                  ;; locations to symbols. This adds about 10% to parse/analysis\n                  ;; time.\n\n                  ;; $ tmp/bb-only-seq-and-sym-locs tmp/meander.clj\n                  ;; \"Elapsed time: 120.448655 msecs\"\n\n                  ;; $ tmp/bb-only-seq-locs tmp/meander.clj\n                  ;; \"Elapsed time: 110.869661 msecs\"\n\n                  (symbol? obj)\n                  ;; same as clojure\n                  (seq? obj)))\n    :end-location false}))\n\n(defn var->sym [v]\n  (when-let [m (meta v)]\n    (when-let [var-name (:name m)]\n      (when-let [ns (:ns m)]\n        (symbol (str (vars/getName ns))\n                (str var-name))))))\n\n(defn fully-qualify [ctx sym]\n  (let [env @(:env ctx)\n        sym-ns (when-let [n (namespace sym)]\n                 (symbol n))\n        sym-name-str (name sym)\n        current-ns (vars/current-ns-name)\n        current-ns-str (str current-ns)\n        namespaces (get env :namespaces)\n        the-current-ns (get namespaces current-ns)\n        aliases (:aliases the-current-ns)\n        ret (if-not sym-ns\n              (or (when-let [refers (:refers the-current-ns)]\n                    (when-let [v (get refers sym)]\n                      (var->sym v)))\n                  (when-let [v (get the-current-ns sym)]\n                    (var->sym v))\n                  (when (or (and (contains? (get namespaces 'clojure.core) sym)\n                                 ;; only valid when the symbol isn't excluded\n                                 (not (some-> the-current-ns\n                                              :refer\n                                              (get 'clojure.core)\n                                              :exclude\n                                              (contains? sym ))))\n                            (contains? utils/ana-macros sym))\n                    (symbol \"clojure.core\" sym-name-str))\n                  (interop/fully-qualify-class ctx sym)\n                  ;; all unresolvable symbols all resolved in the current namespace\n                  (symbol current-ns-str sym-name-str))\n              (if (get-in env [:namespaces sym-ns])\n                sym\n                (if-let [ns (get aliases sym-ns)]\n                  (symbol (str ns) sym-name-str)\n                  sym)))]\n    ret))\n\n(defn parse-next\n  ([ctx r]\n   (parse-next ctx r nil))\n  ([ctx r opts]\n   (let [features (:features ctx)\n         readers (:readers ctx)\n         readers (if (vars/var? readers) @readers readers)\n         env (:env ctx)\n         env-val @env\n         current-ns (vars/current-ns-name)\n         the-current-ns (get-in env-val [:namespaces current-ns])\n         aliases (:aliases the-current-ns)\n         auto-resolve (assoc aliases :current current-ns)\n         parse-opts (cond-> (assoc default-opts\n                                   :features features\n                                   :auto-resolve auto-resolve\n                                   :syntax-quote {:resolve-symbol #(fully-qualify ctx %)}\n                                   :readers readers)\n                      opts (merge opts))\n         ret (try (let [v (edamame/parse-next parse-opts r)]\n                    (if (utils/kw-identical? v :edamame.impl.parser/eof)\n                      eof\n                      v))\n                  (catch #?(:clj clojure.lang.ExceptionInfo\n                            :cljs cljs.core/ExceptionInfo) e\n                    (throw (ex-info #?(:clj (.getMessage e)\n                                       :cljs (.-message e))\n                                    (assoc (ex-data e)\n                                           :type :sci.error/parse\n                                           :phase \"parse\"\n                                           :file @vars/current-file)\n                                    e))))]\n     ret)))\n\n(defn reader [x]\n  #?(:clj (r/indexing-push-back-reader (r/push-back-reader x))\n     :cljs (let [string-reader (r/string-reader x)\n                 buf-len 1\n                 pushback-reader (r/PushbackReader. string-reader\n                                                    (object-array buf-len)\n                                                    buf-len buf-len)]\n             (r/indexing-push-back-reader pushback-reader))))\n\n(defn get-line-number [reader]\n  (r/get-line-number reader))\n\n(defn get-column-number [reader]\n  (r/get-column-number reader))\n\n(defn parse-string\n  ([ctx s]\n   (let [r (reader s)\n         v (parse-next ctx r)]\n     (if (utils/kw-identical? eof v) nil v))))\n\n;;;; Scratch\n\n(comment\n  )\n"]}