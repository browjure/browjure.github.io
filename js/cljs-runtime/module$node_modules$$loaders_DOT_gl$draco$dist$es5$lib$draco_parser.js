shadow$provide.module$node_modules$$loaders_DOT_gl$draco$dist$es5$lib$draco_parser=function(global,require,module,exports){global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;var _slicedToArray2=global(require("module$node_modules$$babel$runtime$helpers$slicedToArray")),_typeof2=global(require("module$node_modules$$babel$runtime$helpers$typeof")),_classCallCheck2=global(require("module$node_modules$$babel$runtime$helpers$classCallCheck")),
_createClass2=global(require("module$node_modules$$babel$runtime$helpers$createClass")),_loaderUtils=require("module$node_modules$$loaders_DOT_gl$loader_utils$dist$es5$index"),DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP={POSITION:"POSITION",NORMAL:"NORMAL",COLOR:"COLOR_0",TEX_COORD:"TEXCOORD_0"},DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP={1:Int8Array,2:Uint8Array,3:Int16Array,4:Uint16Array,5:Int32Array,6:Uint32Array,9:Float32Array};require=function(){function DracoParser(draco){(0,_classCallCheck2["default"])(this,
DracoParser);this.draco=draco;this.drawMode="TRIANGLE";this.metadataQuerier={}}(0,_createClass2["default"])(DracoParser,[{key:"destroy",value:function(){}},{key:"destroyGeometry",value:function(dracoGeometry){dracoGeometry&&this.draco.destroy(dracoGeometry.dracoGeometry)}},{key:"parseSync",value:function(arrayBuffer){var options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};this.metadataQuerier=new this.draco.MetadataQuerier;var buffer=new this.draco.DecoderBuffer;buffer.Init(new Int8Array(arrayBuffer),
arrayBuffer.byteLength);var decoder=new this.draco.Decoder,data={};try{var geometryType=decoder.GetEncodedGeometryType(buffer);switch(geometryType){case this.draco.TRIANGULAR_MESH:var dracoGeometry=new this.draco.Mesh;var dracoStatus=decoder.DecodeBufferToMesh(buffer,dracoGeometry);var header={type:0,faceCount:dracoGeometry.num_faces(),attributeCount:dracoGeometry.num_attributes(),vertexCount:dracoGeometry.num_points()};break;case this.draco.POINT_CLOUD:dracoGeometry=new this.draco.PointCloud;dracoStatus=
decoder.DecodeBufferToPointCloud(buffer,dracoGeometry);header={type:1,attributeCount:dracoGeometry.num_attributes(),vertexCount:dracoGeometry.num_points()};break;default:throw Error("Unknown DRACO geometry type.");}if(!dracoStatus.ok()||!dracoGeometry.ptr){var message="DRACO decompression failed: ".concat(dracoStatus.error_msg());dracoGeometry&&this.draco.destroy(dracoGeometry);throw Error(message);}data.loaderData={header};this._extractDRACOGeometry(decoder,dracoGeometry,geometryType,data,options);
var metadata=this._getGeometryMetadata(decoder,dracoGeometry);data.header={vertexCount:header.vertexCount,boundingBox:(0,_loaderUtils.getMeshBoundingBox)(data.attributes),metadata}}finally{this.draco.destroy(decoder),this.draco.destroy(buffer),this.draco.destroy(dracoGeometry),this.draco.destroy(this.metadataQuerier)}return data}},{key:"_extractDRACOGeometry",value:function(decoder,dracoGeometry,geometryType,geometry,options){options=this._getAttributes(decoder,dracoGeometry,options);if(!options.POSITION)throw Error("DRACO decompressor: No position attribute found.");
geometryType===this.draco.TRIANGULAR_MESH?(options.indices="TRIANGLE_STRIP"===this.drawMode?this._getMeshStripIndices(decoder,dracoGeometry):this._getMeshFaceIndices(decoder,dracoGeometry),geometry.mode="TRIANGLE_STRIP"===this.drawMode?5:4):geometry.mode=0;options.indices&&(geometry.indices={value:options.indices,size:1},delete options.indices);geometry.attributes=options;return geometry}},{key:"getPositionAttributeMetadata",value:function(positionAttribute){this.metadata=this.metadata||{};this.metadata.attributes=
this.metadata.attributes||{};var posTransform=new this.draco.AttributeQuantizationTransform;if(posTransform.InitFromAttribute(positionAttribute))for(this.metadata.attributes.position.isQuantized=!0,this.metadata.attributes.position.maxRange=posTransform.range(),this.metadata.attributes.position.numQuantizationBits=posTransform.quantization_bits(),this.metadata.attributes.position.minValues=new Float32Array(3),positionAttribute=0;3>positionAttribute;++positionAttribute)this.metadata.attributes.position.minValues[positionAttribute]=
posTransform.min_value(positionAttribute);this.draco.destroy(posTransform)}},{key:"_getAttributes",value:function(decoder,dracoGeometry,options){for(var attributes={},numPoints=dracoGeometry.num_points(),attributeId=0;attributeId<dracoGeometry.num_attributes();attributeId++){var dracoAttribute=decoder.GetAttribute(dracoGeometry,attributeId),attributeMetadata=this._getAttributeMetadata(decoder,dracoGeometry,attributeId),attributeData={uniqueId:dracoAttribute.unique_id(),attributeType:dracoAttribute.attribute_type(),
dataType:DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],size:dracoAttribute.size(),numComponents:dracoAttribute.num_components(),byteOffset:dracoAttribute.byte_offset(),byteStride:dracoAttribute.byte_stride(),normalized:dracoAttribute.normalized(),metadata:attributeMetadata};attributeData=this._deduceAttributeName(attributeData,options);dracoAttribute=this._getAttributeTypedArray(decoder,dracoGeometry,dracoAttribute,attributeData).typedArray;attributes[attributeData]={value:dracoAttribute,
size:dracoAttribute.length/numPoints,metadata:attributeMetadata}}return attributes}},{key:"_getMeshFaceIndices",value:function(decoder,dracoGeometry){for(var numFaces=dracoGeometry.num_faces(),indices=new Uint32Array(3*numFaces),dracoArray=new this.draco.DracoInt32Array,i=0;i<numFaces;++i){decoder.GetFaceFromMesh(dracoGeometry,i,dracoArray);var index=3*i;indices[index]=dracoArray.GetValue(0);indices[index+1]=dracoArray.GetValue(1);indices[index+2]=dracoArray.GetValue(2)}this.draco.destroy(dracoArray);
return indices}},{key:"_getMeshStripIndices",value:function(decoder,dracoGeometry){var dracoArray=new this.draco.DracoInt32Array;decoder.GetTriangleStripsFromMesh(dracoGeometry,dracoArray);decoder=new Uint32Array(dracoArray.size());for(dracoGeometry=0;dracoGeometry<dracoArray.size();++dracoGeometry)decoder[dracoGeometry]=dracoArray.GetValue(dracoGeometry);this.draco.destroy(dracoArray);return decoder}},{key:"_getAttributeTypedArray",value:function(decoder,dracoGeometry,dracoAttribute,attributeName){if(0===
dracoAttribute.ptr)throw attributeName="DRACO decode bad attribute ".concat(attributeName),Error(attributeName);var attributeType=DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];attributeName=dracoAttribute.num_components();var numValues=dracoGeometry.num_points()*attributeName;switch(attributeType){case Float32Array:attributeType=new this.draco.DracoFloat32Array;decoder.GetAttributeFloatForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Float32Array(numValues);break;
case Int8Array:attributeType=new this.draco.DracoInt8Array;decoder.GetAttributeInt8ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Int8Array(numValues);break;case Int16Array:attributeType=new this.draco.DracoInt16Array;decoder.GetAttributeInt16ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Int16Array(numValues);break;case Int32Array:attributeType=new this.draco.DracoInt32Array;decoder.GetAttributeInt32ForAllPoints(dracoGeometry,dracoAttribute,attributeType);
decoder=new Int32Array(numValues);break;case Uint8Array:attributeType=new this.draco.DracoUInt8Array;decoder.GetAttributeUInt8ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Uint8Array(numValues);break;case Uint16Array:attributeType=new this.draco.DracoUInt16Array;decoder.GetAttributeUInt16ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Uint16Array(numValues);break;case Uint32Array:attributeType=new this.draco.DracoUInt32Array;decoder.GetAttributeUInt32ForAllPoints(dracoGeometry,
dracoAttribute,attributeType);decoder=new Uint32Array(numValues);break;default:throw Error("DRACO decoder: unexpected attribute type.");}for(dracoGeometry=0;dracoGeometry<numValues;dracoGeometry++)decoder[dracoGeometry]=attributeType.GetValue(dracoGeometry);this.draco.destroy(attributeType);return{typedArray:decoder,components:attributeName}}},{key:"_deduceAttributeName",value:function(attributeData,options){var _options$extraAttribu=options.extraAttributes,extraAttributes=void 0===_options$extraAttribu?
{}:_options$extraAttribu;if(extraAttributes&&"object"===(0,_typeof2["default"])(extraAttributes))for(_options$extraAttribu=0,extraAttributes=Object.entries(extraAttributes);_options$extraAttribu<extraAttributes.length;_options$extraAttribu++){var _Object$entries$_i=(0,_slicedToArray2["default"])(extraAttributes[_options$extraAttribu],2),attributeName=_Object$entries$_i[0];if(_Object$entries$_i[1]===attributeData.uniqueId)return attributeName}for(var dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP)if(attributeData.attributeType===
this.draco[dracoAttributeConstant])return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];return attributeData.metadata&&(options=options.attributeNameEntry||"name",attributeData.metadata[options])?attributeData.metadata[options].string:"CUSTOM_ATTRIBUTE_".concat(attributeData.uniqueId)}},{key:"_getGeometryMetadata",value:function(decoder,dracoGeometry){decoder=decoder.GetMetadata(dracoGeometry);return this._queryDracoMetadata(decoder)}},{key:"_getAttributeMetadata",value:function(decoder,
dracoGeometry,attributeId){decoder=decoder.GetAttributeMetadata(dracoGeometry,attributeId);return this._queryDracoMetadata(decoder)}},{key:"_queryDracoMetadata",value:function(dracoMetadata){if(!dracoMetadata||!dracoMetadata.ptr)return{};for(var result={},numEntries=this.metadataQuerier.NumEntries(dracoMetadata),entryIndex=0;entryIndex<numEntries;entryIndex++){var entryName=this.metadataQuerier.GetEntryName(dracoMetadata,entryIndex);result[entryName]={"int":this.metadataQuerier.GetIntEntry(dracoMetadata,
entryName),string:this.metadataQuerier.GetStringEntry(dracoMetadata,entryName),"double":this.metadataQuerier.GetDoubleEntry(dracoMetadata,entryName),intArray:this.metadataQuerier.GetIntEntryArray(dracoMetadata,entryName)}}return result}},{key:"decode",value:function(arrayBuffer,options){return this.parseSync(arrayBuffer,options)}}]);return DracoParser}();exports["default"]=require}
//# sourceMappingURL=module$node_modules$$loaders_DOT_gl$draco$dist$es5$lib$draco_parser.js.map
