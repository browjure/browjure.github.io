shadow$provide.module$node_modules$$deck_DOT_gl$layers$dist$es5$icon_layer$icon_layer_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian \x3d angle * PI / 180.0;\n  float cos_angle \x3d cos(angle_radian);\n  float sin_angle \x3d sin(angle_radian);\n  mat2 rotationMatrix \x3d mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition \x3d instancePositions;\n  geometry.uv \x3d positions;\n  geometry.pickingColor \x3d instancePickingColors;\n  uv \x3d positions;\n\n  vec2 iconSize \x3d instanceIconFrames.zw;\n  float sizePixels \x3d clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale \x3d iconSize.y \x3d\x3d 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset \x3d positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset \x3d rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset +\x3d instancePixelOffset;\n  pixelOffset.y *\x3d -1.0;\n\n  if (billboard)  {\n    gl_Position \x3d project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset \x3d vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy +\x3d project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common \x3d vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position \x3d project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords \x3d mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor \x3d instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode \x3d instanceColorModes;\n}\n"}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$layers$dist$es5$icon_layer$icon_layer_vertex_glsl.js.map
