shadow$provide.module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$phong_lighting$phong_lighting_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction \x3d normalize(light_direction + view_direction);\n    float lambertian \x3d dot(light_direction, normal_worldspace);\n    float specular \x3d 0.0;\n    if (lambertian \x3e 0.0) {\n      float specular_angle \x3d max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular \x3d pow(specular_angle, lighting_uShininess);\n    }\n    lambertian \x3d max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor \x3d surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction \x3d normalize(cameraPosition - position_worldspace);\n    lightColor \x3d lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i \x3d 0; i \x3c MAX_LIGHTS; i++) {\n      if (i \x3e\x3d lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight \x3d lighting_uPointLight[i];\n      vec3 light_position_worldspace \x3d pointLight.position;\n      vec3 light_direction \x3d normalize(light_position_worldspace - position_worldspace);\n      lightColor +\x3d lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i \x3d 0; i \x3c MAX_LIGHTS; i++) {\n      if (i \x3e\x3d lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight \x3d lighting_uDirectionalLight[i];\n      lightColor +\x3d lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor \x3d vec3(0, 0, 0);\n  vec3 surfaceColor \x3d vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction \x3d normalize(cameraPosition - position_worldspace);\n\n    for (int i \x3d 0; i \x3c MAX_LIGHTS; i++) {\n      if (i \x3e\x3d lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight \x3d lighting_uPointLight[i];\n      vec3 light_position_worldspace \x3d pointLight.position;\n      vec3 light_direction \x3d normalize(light_position_worldspace - position_worldspace);\n      lightColor +\x3d lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i \x3d 0; i \x3c MAX_LIGHTS; i++) {\n      if (i \x3e\x3d lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight \x3d lighting_uDirectionalLight[i];\n      lightColor +\x3d lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n"}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$phong_lighting$phong_lighting_glsl.js.map
