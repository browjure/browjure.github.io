shadow$provide.module$node_modules$$loaders_DOT_gl$terrain$dist$es5$lib$parse_terrain=function(global,require,module,exports){function getMartiniTileMesh(terrainImage,terrainOptions){if(null===terrainImage)return null;var meshMaxError=terrainOptions.meshMaxError,bounds=terrainOptions.bounds,elevationDecoder=terrainOptions.elevationDecoder;terrainOptions=terrainImage.width;var gridSize=terrainOptions+1,imageData=terrainImage.data,rScaler=elevationDecoder.rScaler,bScaler=elevationDecoder.bScaler,gScaler=
elevationDecoder.gScaler,offset=elevationDecoder.offset;terrainImage=terrainOptions+1;elevationDecoder=new Float32Array(terrainImage*terrainImage);for(var i=0,y=0;y<terrainOptions;y++)for(var x=0;x<terrainOptions;x++,i++){var k=4*i;elevationDecoder[i+y]=imageData[k+0]*rScaler+imageData[k+1]*gScaler+imageData[k+2]*bScaler+offset}imageData=terrainImage*(terrainImage-1);for(rScaler=0;rScaler<terrainImage-1;rScaler++,imageData++)elevationDecoder[imageData]=elevationDecoder[imageData-terrainImage];imageData=
terrainImage-1;for(rScaler=0;rScaler<terrainImage;rScaler++,imageData+=terrainImage)elevationDecoder[imageData]=elevationDecoder[imageData-1];gridSize=(new _martini["default"](gridSize)).createTile(elevationDecoder).getMesh(meshMaxError);meshMaxError=gridSize.triangles;gridSize=gridSize.vertices;terrainImage=terrainOptions+1;imageData=gridSize.length/2;rScaler=new Float32Array(3*imageData);bScaler=new Float32Array(2*imageData);bounds=bounds||[0,0,terrainOptions,terrainOptions];i=(0,_slicedToArray2["default"])(bounds,
4);bounds=i[0];gScaler=i[3];offset=(i[2]-bounds)/terrainOptions;i=(gScaler-i[1])/terrainOptions;for(y=0;y<imageData;y++){x=gridSize[2*y];k=gridSize[2*y+1];var pixelIdx=k*terrainImage+x;rScaler[3*y]=x*offset+bounds;rScaler[3*y+1]=-k*i+gScaler;rScaler[3*y+2]=elevationDecoder[pixelIdx];bScaler[2*y]=x/terrainOptions;bScaler[2*y+1]=k/terrainOptions}terrainOptions={POSITION:{value:rScaler,size:3},TEXCOORD_0:{value:bScaler,size:2}};return{loaderData:{header:{}},header:{vertexCount:meshMaxError.length,boundingBox:(0,
_loaderUtils.getMeshBoundingBox)(terrainOptions)},mode:4,indices:{value:meshMaxError,size:1},attributes:terrainOptions}}function _loadTerrain(){_loadTerrain=(0,_asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(arrayBuffer,options,context){var image;return _regenerator["default"].wrap(function(_context){for(;;)switch(_context.prev=_context.next){case 0:return options.image=options.image||{},options.image.type="data",_context.next=4,context.parse(arrayBuffer,options,options.baseUri);
case 4:return image=_context.sent,_context.abrupt("return",getMartiniTileMesh(image,options.terrain));case 6:case "end":return _context.stop()}},_callee)}));return _loadTerrain.apply(this,arguments)}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=function(_x2,_x3,_x4){return _loadTerrain.apply(this,arguments)};var _regenerator=global(require("module$node_modules$$babel$runtime$regenerator$index")),
_asyncToGenerator2=global(require("module$node_modules$$babel$runtime$helpers$asyncToGenerator")),_slicedToArray2=global(require("module$node_modules$$babel$runtime$helpers$slicedToArray")),_martini=global(require("module$node_modules$$mapbox$martini$martini")),_loaderUtils=require("module$node_modules$$loaders_DOT_gl$loader_utils$dist$es5$index")}
//# sourceMappingURL=module$node_modules$$loaders_DOT_gl$terrain$dist$es5$lib$parse_terrain.js.map
