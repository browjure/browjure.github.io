shadow$provide.module$node_modules$$luma_DOT_gl$experimental$dist$es5$gpgpu$point_in_polygon$polygon=function(global,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if("undefined"===typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},
e:function(_e){throw _e;},f:allowArrayLike}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=o[Symbol.iterator]()},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it["return"])it["return"]()}finally{if(didErr)throw err;}}}}function _unsupportedIterableToArray(o,
minLen){if(o){if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);"Object"===n&&o.constructor&&(n=o.constructor.name);if("Map"===n||"Set"===n)return Array.from(o);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function validate(polygon){polygon=
polygon&&polygon.positions||polygon;if(!Array.isArray(polygon)&&!ArrayBuffer.isView(polygon))throw Error("invalid polygon");}function isSimple(polygon){return 1<=polygon.length&&2<=polygon[0].length&&Number.isFinite(polygon[0][0])}function isNestedRingClosed(simplePolygon){var p0=simplePolygon[0];simplePolygon=simplePolygon[simplePolygon.length-1];return p0[0]===simplePolygon[0]&&p0[1]===simplePolygon[1]&&p0[2]===simplePolygon[2]}function isFlatRingClosed(positions,size,startIndex,endIndex){for(var i=
0;i<size;i++)if(positions[startIndex+i]!==positions[endIndex-size+i])return!1;return!0}function copyNestedRing(target,targetStartIndex,simplePolygon,size){for(var len=simplePolygon.length,i=0;i<len;i++)for(var j=0;j<size;j++)target[targetStartIndex++]=simplePolygon[i][j]||0;if(!isNestedRingClosed(simplePolygon))for(len=0;len<size;len++)target[targetStartIndex++]=simplePolygon[0][len]||0;return targetStartIndex}function copyFlatRing(target,targetStartIndex,positions,size){var srcStartIndex=4<arguments.length&&
void 0!==arguments[4]?arguments[4]:0,srcEndIndex=5<arguments.length?arguments[5]:void 0;srcEndIndex=srcEndIndex||positions.length;var srcLength=srcEndIndex-srcStartIndex;if(0>=srcLength)return targetStartIndex;for(var targetIndex=targetStartIndex,i=0;i<srcLength;i++)target[targetIndex++]=positions[srcStartIndex+i];if(!isFlatRingClosed(positions,size,srcStartIndex,srcEndIndex))for(srcEndIndex=0;srcEndIndex<size;srcEndIndex++)target[targetIndex++]=positions[srcStartIndex+srcEndIndex];return targetIndex}
function getNestedVertexCount(simplePolygon){return(isNestedRingClosed(simplePolygon)?0:1)+simplePolygon.length}function getFlatVertexCount(positions,size){var startIndex=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,endIndex=3<arguments.length?arguments[3]:void 0;endIndex=endIndex||positions.length;return startIndex>=endIndex?0:(isFlatRingClosed(positions,size,startIndex,endIndex)?0:1)+(endIndex-startIndex)/size}function getVertexCount(polygon,positionSize){if(2<arguments.length&&void 0!==
arguments[2]&&!arguments[2])return polygon=polygon.positions||polygon,polygon.length/positionSize;validate(polygon);if(polygon.positions){var _polygon=polygon,positions=_polygon.positions;if(_polygon=_polygon.holeIndices){var vertexCount=0;for(positions=0;positions<=_polygon.length;positions++)vertexCount+=getFlatVertexCount(polygon.positions,positionSize,_polygon[positions-1],_polygon[positions]);return vertexCount}polygon=positions}if(Number.isFinite(polygon[0]))return getFlatVertexCount(polygon,
positionSize);if(!isSimple(polygon)){_polygon=0;positions=_createForOfIteratorHelper(polygon);try{for(positions.s();!(vertexCount=positions.n()).done;)_polygon+=getNestedVertexCount(vertexCount.value)}catch(err){positions.e(err)}finally{positions.f()}return _polygon}return getNestedVertexCount(polygon)}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports.getVertexCount=getVertexCount;exports.normalize=function(polygon,
positionSize,vertexCount){validate(polygon);vertexCount=vertexCount||getVertexCount(polygon,positionSize);vertexCount=new Float64Array(vertexCount*positionSize);var holeIndices=[];if(polygon.positions){var _polygon2=polygon;polygon=_polygon2.positions;if(_polygon2=_polygon2.holeIndices){for(var targetIndex=0,i=0;i<=_polygon2.length;i++)targetIndex=copyFlatRing(vertexCount,targetIndex,polygon,positionSize,_polygon2[i-1],_polygon2[i]),holeIndices.push(targetIndex);holeIndices.pop();return{positions:vertexCount,
holeIndices}}}if(Number.isFinite(polygon[0]))return copyFlatRing(vertexCount,0,polygon,positionSize),vertexCount;if(!isSimple(polygon)){_polygon2=0;polygon=_createForOfIteratorHelper(polygon);try{for(polygon.s();!(targetIndex=polygon.n()).done;)_polygon2=copyNestedRing(vertexCount,_polygon2,targetIndex.value,positionSize),holeIndices.push(_polygon2)}catch(err){polygon.e(err)}finally{polygon.f()}holeIndices.pop();return{positions:vertexCount,holeIndices}}copyNestedRing(vertexCount,0,polygon,positionSize);
return vertexCount};exports.getSurfaceIndices=function(normalizedPolygon,positionSize,preproject){var holeIndices=null;normalizedPolygon.holeIndices&&(holeIndices=normalizedPolygon.holeIndices.map(function(positionIndex){return positionIndex/positionSize}));normalizedPolygon=normalizedPolygon.positions||normalizedPolygon;if(preproject){preproject=normalizedPolygon.length;normalizedPolygon=normalizedPolygon.slice();for(var i=0;i<preproject;i+=positionSize)normalizedPolygon[i+1]=Math.log(Math.tan(PI_4+
normalizedPolygon[i+1]*DEGREES_TO_RADIANS_HALF))}return(0,_earcut["default"])(normalizedPolygon,holeIndices,positionSize)};var _earcut=global(require("module$node_modules$earcut$src$earcut")),PI_4=Math.PI/4,DEGREES_TO_RADIANS_HALF=Math.PI/360}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$experimental$dist$es5$gpgpu$point_in_polygon$polygon.js.map
