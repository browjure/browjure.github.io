shadow$provide.module$node_modules$$deck_DOT_gl$core$dist$es5$shaderlib$project$project_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;var _constants=require("module$node_modules$$deck_DOT_gl$core$dist$es5$lib$constants");global=Object.keys(_constants.COORDINATE_SYSTEM).map(function(key){return"const int COORDINATE_SYSTEM_".concat(key," \x3d ").concat(_constants.COORDINATE_SYSTEM[key],";")}).join("");require=Object.keys(_constants.PROJECTION_MODE).map(function(key){return"const int PROJECTION_MODE_".concat(key,
" \x3d ").concat(_constants.PROJECTION_MODE[key],";")}).join("");global="".concat(global,"\n").concat(require,"\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\n\nconst float TILE_SIZE \x3d 512.0;\nconst float PI \x3d 3.1415926536;\nconst float WORLD_SCALE \x3d TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW \x3d vec3(0.0);\nconst float EARTH_RADIUS \x3d 6370972.0;\nconst float GLOBE_RADIUS \x3d 256.0;\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z;\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy;\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter;\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace \x3d project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy \x3d offset.y;\n  if (project_uCoordinateSystem \x3d\x3d COORDINATE_SYSTEM_LNGLAT) {\n    dy \x3d clamp(dy, -1., 1.);\n  }\n  vec3 commonUnitsPerWorldUnit \x3d project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x \x3d lnglat.x;\n  if (project_uWrapLongitude) {\n    x \x3d mod(x + 180., 360.0) - 180.;\n  }\n  float y \x3d clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  );\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda \x3d radians(lnglatz.x);\n  float phi \x3d radians(lnglatz.y);\n  float cosPhi \x3d cos(phi);\n  float D \x3d (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world \x3d project_uModelMatrix * position;\n  if (project_uProjectionMode \x3d\x3d PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem \x3d\x3d COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy) * WORLD_SCALE,\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem \x3d\x3d COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz +\x3d project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode \x3d\x3d PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem \x3d\x3d COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode \x3d\x3d PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode \x3d\x3d PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET \x26\x26\n    (project_uCoordinateSystem \x3d\x3d COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem \x3d\x3d COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -\x3d project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position \x3d project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position \x3d project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position \x3d project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset \x3d pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz \x3d normalize(up);\n  vec3 ux \x3d abs(uz.z) \x3d\x3d 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy \x3d cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode \x3d\x3d PROJECTION_MODE_GLOBE) {\n    transform \x3d project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n");
exports["default"]=global}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$core$dist$es5$shaderlib$project$project_glsl.js.map
