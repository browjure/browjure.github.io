shadow$provide.module$node_modules$$deck_DOT_gl$layers$dist$es5$line_layer$line_layer_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace \x3d normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace \x3d vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t \x3d (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition \x3d instanceSourcePositions;\n  geometry.worldPositionAlt \x3d instanceTargetPositions;\n\n  vec3 source_world \x3d instanceSourcePositions;\n  vec3 target_world \x3d instanceTargetPositions;\n  vec3 source_world_64low \x3d instanceSourcePositions64Low;\n  vec3 target_world_64low \x3d instanceTargetPositions64Low;\n\n  if (useShortestPath \x3e 0.5 || useShortestPath \x3c -0.5) {\n    source_world.x \x3d mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x \x3d mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng \x3d target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath \x3e 180.) {\n      source_world.x +\x3d 360. * useShortestPath;\n      source_world \x3d splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low \x3d vec3(0.0);\n    } else if (deltaLng * useShortestPath \x3c -180.) {\n      target_world.x +\x3d 360. * useShortestPath;\n      target_world \x3d splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low \x3d vec3(0.0);\n    } else if (useShortestPath \x3c 0.) {\n      gl_Position \x3d vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source \x3d project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target \x3d project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float widthPixels \x3d clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  float segmentIndex \x3d positions.x;\n  vec4 p \x3d mix(source, target, segmentIndex);\n  geometry.position \x3d mix(source_commonspace, target_commonspace, segmentIndex);\n  uv \x3d positions.xy;\n  geometry.uv \x3d uv;\n  geometry.pickingColor \x3d instancePickingColors;\n  vec3 offset \x3d vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position \x3d p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vColor \x3d vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n"}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$layers$dist$es5$line_layer$line_layer_vertex_glsl.js.map
