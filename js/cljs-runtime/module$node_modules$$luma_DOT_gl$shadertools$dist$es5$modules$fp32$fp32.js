shadow$provide.module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$fp32$fp32=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.fp32=void 0;exports.fp32={name:"fp32",vs:"#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI \x3d 6.2831854820251465;\nconst float PI_2 \x3d 1.5707963705062866;\nconst float PI_16 \x3d 0.1963495463132858;\n\nconst float SIN_TABLE_0 \x3d 0.19509032368659973;\nconst float SIN_TABLE_1 \x3d 0.3826834261417389;\nconst float SIN_TABLE_2 \x3d 0.5555702447891235;\nconst float SIN_TABLE_3 \x3d 0.7071067690849304;\n\nconst float COS_TABLE_0 \x3d 0.9807852506637573;\nconst float COS_TABLE_1 \x3d 0.9238795042037964;\nconst float COS_TABLE_2 \x3d 0.8314695954322815;\nconst float COS_TABLE_3 \x3d 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 \x3d 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 \x3d 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 \x3d 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 \x3d 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a \x3d\x3d 0.0) {\n    return 0.0;\n  }\n\n  x \x3d -a * a;\n  s \x3d a;\n  r \x3d a;\n\n  r \x3d r * x;\n  t \x3d r * INVERSE_FACTORIAL_3;\n  s \x3d s + t;\n\n  r \x3d r * x;\n  t \x3d r * INVERSE_FACTORIAL_5;\n  s \x3d s + t;\n\n  r \x3d r * x;\n  t \x3d r * INVERSE_FACTORIAL_7;\n  s \x3d s + t;\n\n  r \x3d r * x;\n  t \x3d r * INVERSE_FACTORIAL_9;\n  s \x3d s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a \x3d\x3d 0.0) {\n    sin_t \x3d 0.0;\n    cos_t \x3d 1.0;\n  }\n  sin_t \x3d sin_taylor_fp32(a);\n  cos_t \x3d sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a \x3d\x3d 0.0) {\n        return 0.0;\n    }\n    float z \x3d floor(a / TWO_PI);\n    float r \x3d a - TWO_PI * z;\n\n    float t;\n    float q \x3d floor(r / PI_2 + 0.5);\n    int j \x3d int(q);\n\n    if (j \x3c -2 || j \x3e 2) {\n        return 0.0 / 0.0;\n    }\n\n    t \x3d r - PI_2 * q;\n\n    q \x3d floor(t / PI_16 + 0.5);\n    int k \x3d int(q);\n    int abs_k \x3d int(abs(float(k)));\n\n    if (abs_k \x3e 4) {\n        return 0.0 / 0.0;\n    } else {\n        t \x3d t - PI_16 * q;\n    }\n\n    float u \x3d 0.0;\n    float v \x3d 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k \x3d\x3d 0) {\n        s \x3d sin_t;\n        c \x3d cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) \x3c 0.5) {\n            u \x3d COS_TABLE_0;\n            v \x3d SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) \x3c 0.5) {\n            u \x3d COS_TABLE_1;\n            v \x3d SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) \x3c 0.5) {\n            u \x3d COS_TABLE_2;\n            v \x3d SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) \x3c 0.5) {\n            u \x3d COS_TABLE_3;\n            v \x3d SIN_TABLE_3;\n        }\n        if (k \x3e 0) {\n            s \x3d u * sin_t + v * cos_t;\n            c \x3d u * cos_t - v * sin_t;\n        } else {\n            s \x3d u * sin_t - v * cos_t;\n            c \x3d u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j \x3d\x3d 0) {\n        sin_a \x3d s;\n        cos_a \x3d c;\n    } else if (j \x3d\x3d 1) {\n        sin_a \x3d c;\n        cos_a \x3d -s;\n    } else if (j \x3d\x3d -1) {\n        sin_a \x3d -c;\n        cos_a \x3d s;\n    } else {\n        sin_a \x3d -s;\n        cos_a \x3d -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n",
fs:null}}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$fp32$fp32.js.map
