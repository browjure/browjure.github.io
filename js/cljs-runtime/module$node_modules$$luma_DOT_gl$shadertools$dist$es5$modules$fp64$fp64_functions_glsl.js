shadow$provide.module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$fp64$fp64_functions_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="const vec2 E_FP64 \x3d vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 \x3d vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 \x3d vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 \x3d vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 \x3d vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 \x3d vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 \x3d vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 \x3d vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 \x3d vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 \x3d vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 \x3d vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 \x3d vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 \x3d vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 \x3d vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 \x3d vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 \x3d vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 \x3d vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 \x3d vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 \x3d vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 \x3d vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 \x3d vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 \x3d vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 \x3d vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 \x3d vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 \x3d vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 \x3d vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d \x3d\x3d floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi \x3d nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi \x3d\x3d a.x) {\n        lo \x3d nint(a.y);\n        tmp \x3d quickTwoSum(hi, lo);\n    } else {\n        lo \x3d 0.0;\n        if (abs(hi - a.x) \x3d\x3d 0.5 \x26\x26 a.y \x3c 0.0) {\n            hi -\x3d 1.0;\n        }\n        tmp \x3d vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power \x3d 4;\n  const float k \x3d 16.0;\n\n  const float inv_k \x3d 1.0 / k;\n\n  if (a.x \x3c\x3d -88.0) return vec2(0.0, 0.0);\n  if (a.x \x3e\x3d 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x \x3d\x3d 0.0 \x26\x26 a.y \x3d\x3d 0.0) return vec2(1.0, 0.0);\n  if (a.x \x3d\x3d 1.0 \x26\x26 a.y \x3d\x3d 0.0) return E_FP64;\n\n  float m \x3d floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r \x3d sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p \x3d mul_fp64(r, r);\n  s \x3d sum_fp64(r, p * 0.5);\n  p \x3d mul_fp64(p, r);\n  t \x3d mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s \x3d sum_fp64(s, t);\n  p \x3d mul_fp64(p, r);\n  t \x3d mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s \x3d sum_fp64(s, t);\n  p \x3d mul_fp64(p, r);\n  t \x3d mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s \x3d sum_fp64(s, t);\n  for (int i \x3d 0; i \x3c k_power; i++) {\n    s \x3d sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s \x3d sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s \x3d sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x \x3d\x3d 1.0 \x26\x26 a.y \x3d\x3d 0.0) return vec2(0.0, 0.0);\n  if (a.x \x3c\x3d 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x \x3d vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s \x3d vec2(ONE, 0.0);\n#else\n  s \x3d vec2(1.0, 0.0);\n#endif\n\n  x \x3d sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x \x3d\x3d 0.0 \x26\x26 a.y \x3d\x3d 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x \x3d -mul_fp64(a, a);\n  s \x3d a;\n  r \x3d a;\n\n  r \x3d mul_fp64(r, x);\n  t \x3d mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s \x3d sum_fp64(s, t);\n\n  r \x3d mul_fp64(r, x);\n  t \x3d mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s \x3d sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x \x3d\x3d 0.0 \x26\x26 a.y \x3d\x3d 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x \x3d -mul_fp64(a, a);\n  r \x3d x;\n  s \x3d sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r \x3d mul_fp64(r, x);\n  t \x3d mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s \x3d sum_fp64(s, t);\n\n  r \x3d mul_fp64(r, x);\n  t \x3d mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s \x3d sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x \x3d\x3d 0.0 \x26\x26 a.y \x3d\x3d 0.0) {\n    sin_t \x3d vec2(0.0, 0.0);\n    cos_t \x3d vec2(1.0, 0.0);\n  }\n\n  sin_t \x3d sin_taylor_fp64(a);\n  cos_t \x3d sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x \x3d\x3d 0.0 \x26\x26 a.y \x3d\x3d 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z \x3d nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r \x3d sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q \x3d floor(r.x / PI_2_FP64.x + 0.5);\n    int j \x3d int(q);\n\n    if (j \x3c -2 || j \x3e 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t \x3d sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q \x3d floor(t.x / PI_16_FP64.x + 0.5);\n    int k \x3d int(q);\n\n    if (k \x3d\x3d 0) {\n        if (j \x3d\x3d 0) {\n            return sin_taylor_fp64(t);\n        } else if (j \x3d\x3d 1) {\n            return cos_taylor_fp64(t);\n        } else if (j \x3d\x3d -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k \x3d int(abs(float(k)));\n\n    if (abs_k \x3e 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t \x3d sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u \x3d vec2(0.0, 0.0);\n    vec2 v \x3d vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) \x3c 0.5) {\n        u \x3d COS_TABLE_0_FP64;\n        v \x3d SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) \x3c 0.5) {\n        u \x3d COS_TABLE_1_FP64;\n        v \x3d SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) \x3c 0.5) {\n        u \x3d COS_TABLE_2_FP64;\n        v \x3d SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) \x3c 0.5) {\n        u \x3d COS_TABLE_3_FP64;\n        v \x3d SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k \x3d\x3d 1) {\n        u \x3d COS_TABLE_0_FP64;\n        v \x3d SIN_TABLE_0_FP64;\n    } else if (abs_k \x3d\x3d 2) {\n        u \x3d COS_TABLE_1_FP64;\n        v \x3d SIN_TABLE_1_FP64;\n    } else if (abs_k \x3d\x3d 3) {\n        u \x3d COS_TABLE_2_FP64;\n        v \x3d SIN_TABLE_2_FP64;\n    } else if (abs_k \x3d\x3d 4) {\n        u \x3d COS_TABLE_3_FP64;\n        v \x3d SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result \x3d vec2(0.0, 0.0);\n    if (j \x3d\x3d 0) {\n        if (k \x3e 0) {\n            result \x3d sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result \x3d sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j \x3d\x3d 1) {\n        if (k \x3e 0) {\n            result \x3d sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result \x3d sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j \x3d\x3d -1) {\n        if (k \x3e 0) {\n            result \x3d sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result \x3d -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k \x3e 0) {\n            result \x3d -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result \x3d sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x \x3d\x3d 0.0 \x26\x26 a.y \x3d\x3d 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z \x3d nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r \x3d sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q \x3d floor(r.x / PI_2_FP64.x + 0.5);\n    int j \x3d int(q);\n\n    if (j \x3c -2 || j \x3e 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t \x3d sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q \x3d floor(t.x / PI_16_FP64.x + 0.5);\n    int k \x3d int(q);\n\n    if (k \x3d\x3d 0) {\n        if (j \x3d\x3d 0) {\n            return cos_taylor_fp64(t);\n        } else if (j \x3d\x3d 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j \x3d\x3d -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k \x3d int(abs(float(k)));\n\n    if (abs_k \x3e 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t \x3d sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u \x3d vec2(0.0, 0.0);\n    vec2 v \x3d vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) \x3c 0.5) {\n        u \x3d COS_TABLE_0_FP64;\n        v \x3d SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) \x3c 0.5) {\n        u \x3d COS_TABLE_1_FP64;\n        v \x3d SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) \x3c 0.5) {\n        u \x3d COS_TABLE_2_FP64;\n        v \x3d SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) \x3c 0.5) {\n        u \x3d COS_TABLE_3_FP64;\n        v \x3d SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k \x3d\x3d 1) {\n        u \x3d COS_TABLE_0_FP64;\n        v \x3d SIN_TABLE_0_FP64;\n    } else if (abs_k \x3d\x3d 2) {\n        u \x3d COS_TABLE_1_FP64;\n        v \x3d SIN_TABLE_1_FP64;\n    } else if (abs_k \x3d\x3d 3) {\n        u \x3d COS_TABLE_2_FP64;\n        v \x3d SIN_TABLE_2_FP64;\n    } else if (abs_k \x3d\x3d 4) {\n        u \x3d COS_TABLE_3_FP64;\n        v \x3d SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result \x3d vec2(0.0, 0.0);\n    if (j \x3d\x3d 0) {\n        if (k \x3e 0) {\n            result \x3d sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result \x3d sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j \x3d\x3d 1) {\n        if (k \x3e 0) {\n            result \x3d -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result \x3d sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j \x3d\x3d -1) {\n        if (k \x3e 0) {\n            result \x3d sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result \x3d sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k \x3e 0) {\n            result \x3d sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result \x3d -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x \x3d\x3d 0.0 \x26\x26 a.y \x3d\x3d 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z \x3d nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r \x3d sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q \x3d floor(r.x / PI_2_FP64.x + 0.5);\n    int j \x3d int(q);\n\n\n    if (j \x3c -2 || j \x3e 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t \x3d sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q \x3d floor(t.x / PI_16_FP64.x + 0.5);\n    int k \x3d int(q);\n    int abs_k \x3d int(abs(float(k)));\n\n    if (abs_k \x3e 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t \x3d sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u \x3d vec2(0.0, 0.0);\n    vec2 v \x3d vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k \x3d\x3d 0) {\n        s \x3d sin_t;\n        c \x3d cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) \x3c 0.5) {\n            u \x3d COS_TABLE_0_FP64;\n            v \x3d SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) \x3c 0.5) {\n            u \x3d COS_TABLE_1_FP64;\n            v \x3d SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) \x3c 0.5) {\n            u \x3d COS_TABLE_2_FP64;\n            v \x3d SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) \x3c 0.5) {\n            u \x3d COS_TABLE_3_FP64;\n            v \x3d SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k \x3d\x3d 1) {\n            u \x3d COS_TABLE_0_FP64;\n            v \x3d SIN_TABLE_0_FP64;\n        } else if (abs_k \x3d\x3d 2) {\n            u \x3d COS_TABLE_1_FP64;\n            v \x3d SIN_TABLE_1_FP64;\n        } else if (abs_k \x3d\x3d 3) {\n            u \x3d COS_TABLE_2_FP64;\n            v \x3d SIN_TABLE_2_FP64;\n        } else if (abs_k \x3d\x3d 4) {\n            u \x3d COS_TABLE_3_FP64;\n            v \x3d SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k \x3e 0) {\n            s \x3d sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c \x3d sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s \x3d sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c \x3d sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j \x3d\x3d 0) {\n        sin_a \x3d s;\n        cos_a \x3d c;\n    } else if (j \x3d\x3d 1) {\n        sin_a \x3d c;\n        cos_a \x3d -s;\n    } else if (j \x3d\x3d -1) {\n        sin_a \x3d -c;\n        cos_a \x3d s;\n    } else {\n        sin_a \x3d -s;\n        cos_a \x3d -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range \x3d sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] \x3d sum_fp64(a[0], b[0]);\n    out_val[1] \x3d sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] \x3d sub_fp64(a[0], b[0]);\n    out_val[1] \x3d sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] \x3d mul_fp64(a[0], b[0]);\n    out_val[1] \x3d mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] \x3d div_fp64(a[0], b[0]);\n    out_val[1] \x3d div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] \x3d range[0] * a;\n  portion[1] \x3d range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length \x3d vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] \x3d length;\n  length_vec2[1] \x3d length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] \x3d mul_fp64(a[0], b[0]);\n  v[1] \x3d mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i \x3d 0; i \x3c 3; i++) {\n    out_val[i] \x3d sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i \x3d 0; i \x3c 3; i++) {\n    out_val[i] \x3d sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x \x3d a[0];\n  out_val[0].y \x3d 0.0;\n\n  out_val[1].x \x3d a[1];\n  out_val[1].y \x3d 0.0;\n\n  out_val[2].x \x3d a[2];\n  out_val[2].y \x3d 0.0;\n\n  out_val[3].x \x3d a[3];\n  out_val[3].y \x3d 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] \x3d mul_fp64(a[0], b);\n  out_val[1] \x3d mul_fp64(a[1], b);\n  out_val[2] \x3d mul_fp64(a[2], b);\n  out_val[3] \x3d mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i \x3d 0; i \x3c 4; i++) {\n    out_val[i] \x3d sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] \x3d mul_fp64(a[0], b[0]);\n  v[1] \x3d mul_fp64(a[1], b[1]);\n  v[2] \x3d mul_fp64(a[2], b[2]);\n  v[3] \x3d mul_fp64(a[3], b[3]);\n\n  out_val \x3d sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i \x3d 0; i \x3c 4; i++)\n  {\n    for (int j \x3d 0; j \x3c 4; j++)\n    {\n      tmp[j] \x3d b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n"}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$shadertools$dist$es5$modules$fp64$fp64_functions_glsl.js.map
