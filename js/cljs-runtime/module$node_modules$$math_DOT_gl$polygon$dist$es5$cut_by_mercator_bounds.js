shadow$provide.module$node_modules$$math_DOT_gl$polygon$dist$es5$cut_by_mercator_bounds=function(global,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if("undefined"===typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},e:function(_e){throw _e;
},f:allowArrayLike}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=o[Symbol.iterator]()},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it["return"])it["return"]()}finally{if(didErr)throw err;}}}}function _unsupportedIterableToArray(o,
minLen){if(o){if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);"Object"===n&&o.constructor&&(n=o.constructor.name);if("Map"===n||"Set"===n)return Array.from(o);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function insertPoleVertices(positions,
size,startIndex,endIndex){var maxLatitude=4<arguments.length&&void 0!==arguments[4]?arguments[4]:DEFAULT_MAX_LATITUDE,firstLng=positions[startIndex],lastLng=positions[endIndex-size];if(180<Math.abs(firstLng-lastLng)){var p=(0,_utils.getPointAtIndex)(positions,0,size,startIndex);p[0]+=360*Math.round((lastLng-firstLng)/360);(0,_utils.push)(positions,p);p[1]=Math.sign(p[1])*maxLatitude;(0,_utils.push)(positions,p);p[0]=firstLng;(0,_utils.push)(positions,p)}}function wrapLongitudesForShortestPath(positions,
size,startIndex,endIndex){for(var prevLng=positions[0],i=startIndex;i<endIndex;i+=size){startIndex=positions[i];prevLng=startIndex-prevLng;if(180<prevLng||-180>prevLng)startIndex-=360*Math.round(prevLng/360);positions[i]=prevLng=startIndex}}function shiftLongitudesIntoRange(positions,size){for(var refLng,pointCount=positions.length/size,i=0;i<pointCount&&(refLng=positions[i*size],0===(refLng+180)%360);i++);refLng=360*-Math.round(refLng/360);if(0!==refLng)for(i=0;i<pointCount;i++)positions[i*size]+=
refLng}Object.defineProperty(exports,"__esModule",{value:!0});exports.cutPolylineByMercatorBounds=function(positions){var options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},_options$size=options.size;_options$size=void 0===_options$size?2:_options$size;var _options$startIndex=options.startIndex;_options$startIndex=void 0===_options$startIndex?0:_options$startIndex;var _options$endIndex=options.endIndex;_options$endIndex=void 0===_options$endIndex?positions.length:_options$endIndex;
options=options.normalize;options=void 0===options?!0:options;var newPositions=positions.slice(_options$startIndex,_options$endIndex);wrapLongitudesForShortestPath(newPositions,_options$size,0,_options$endIndex-_options$startIndex);_options$startIndex=(0,_cutByGrid.cutPolylineByGrid)(newPositions,{size:_options$size,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(options){options=_createForOfIteratorHelper(_options$startIndex);var _step;try{for(options.s();!(_step=options.n()).done;)shiftLongitudesIntoRange(_step.value,
_options$size)}catch(err){options.e(err)}finally{options.f()}}return _options$startIndex};exports.cutPolygonByMercatorBounds=function(positions,holeIndices){var options=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},_options$size2=options.size;_options$size2=void 0===_options$size2?2:_options$size2;var _options$normalize2=options.normalize;_options$normalize2=void 0===_options$normalize2?!0:_options$normalize2;var _options$edgeTypes=options.edgeTypes;_options$edgeTypes=void 0===_options$edgeTypes?
!1:_options$edgeTypes;holeIndices=holeIndices||[];for(var newPositions=[],newHoleIndices=[],srcStartIndex=0,targetIndex=0,ringIndex=0;ringIndex<=holeIndices.length;ringIndex++){for(var srcEndIndex=holeIndices[ringIndex]||positions.length,targetStartIndex=targetIndex,splitIndex,pointIndex=splitIndex=-1,i=srcStartIndex+1;i<srcEndIndex;i+=_options$size2){var lat=Math.abs(positions[i]);lat>splitIndex&&(splitIndex=lat,pointIndex=i-1)}for(pointIndex=splitIndex=pointIndex;pointIndex<srcEndIndex;pointIndex++)newPositions[targetIndex++]=
positions[pointIndex];for(;srcStartIndex<splitIndex;srcStartIndex++)newPositions[targetIndex++]=positions[srcStartIndex];wrapLongitudesForShortestPath(newPositions,_options$size2,targetStartIndex,targetIndex);insertPoleVertices(newPositions,_options$size2,targetStartIndex,targetIndex,options.maxLatitude);srcStartIndex=srcEndIndex;newHoleIndices[ringIndex]=targetIndex}newHoleIndices.pop();options=(0,_cutByGrid.cutPolygonByGrid)(newPositions,newHoleIndices,{size:_options$size2,gridResolution:360,gridOffset:[-180,
-180],edgeTypes:_options$edgeTypes});if(_options$normalize2){_options$normalize2=_createForOfIteratorHelper(options);var _step2;try{for(_options$normalize2.s();!(_step2=_options$normalize2.n()).done;)shiftLongitudesIntoRange(_step2.value.positions,_options$size2)}catch(err){_options$normalize2.e(err)}finally{_options$normalize2.f()}}return options};var _cutByGrid=require("module$node_modules$$math_DOT_gl$polygon$dist$es5$cut_by_grid"),_utils=require("module$node_modules$$math_DOT_gl$polygon$dist$es5$utils"),
DEFAULT_MAX_LATITUDE=85.051129}
//# sourceMappingURL=module$node_modules$$math_DOT_gl$polygon$dist$es5$cut_by_mercator_bounds.js.map
