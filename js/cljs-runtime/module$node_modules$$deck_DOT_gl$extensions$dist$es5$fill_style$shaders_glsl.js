shadow$provide.module$node_modules$$deck_DOT_gl$extensions$dist$es5$fill_style$shaders_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.patternShaders=void 0;var _core=require("module$node_modules$$deck_DOT_gl$core$dist$es5$index");exports.patternShaders={name:"fill-pattern",vs:"\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec3 fill_patternPlacement;\n",
fs:"\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\n\nvarying vec4 fill_patternBounds;\nvarying vec3 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE \x3d 512.0 / 40000000.0;\n",inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    fill_uv \x3d geometry.position.xy;\n  ","vs:DECKGL_FILTER_COLOR":"\n    if (fill_patternEnabled) {\n      fill_patternBounds \x3d FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy \x3d FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.z \x3d FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.w;\n    }\n  ",
"fs:DECKGL_FILTER_COLOR":"\n    if (fill_patternEnabled) {\n      float scale \x3d FILL_UV_SCALE * fill_patternPlacement.z;\n      vec2 patternUV \x3d mod(mod(fill_uvCoordinateOrigin, scale) + fill_uv, scale) / scale;\n      patternUV \x3d mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords \x3d fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n\n      vec4 patternColor \x3d texture2D(fill_patternTexture, texCoords);\n      color.a *\x3d patternColor.a;\n      if (!fill_patternMask) {\n        color.rgb \x3d patternColor.rgb;\n      }\n    }\n  "},
dependencies:[_core.project],getUniforms:function(){var opts=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},uniforms=1<arguments.length?arguments[1]:void 0;if("fillPatternTexture"in opts)return uniforms=opts.fillPatternTexture,{fill_patternTexture:uniforms,fill_patternTextureSize:[uniforms.width,uniforms.height]};if(opts.viewport){var viewport=opts.viewport,_opts$fillPatternMask=opts.fillPatternMask;_opts$fillPatternMask=void 0===_opts$fillPatternMask?!0:_opts$fillPatternMask;opts=opts.fillPatternEnabled;
opts=void 0===opts?!0:opts;var project_uCoordinateOrigin=uniforms.project_uCoordinateOrigin;return{fill_uvCoordinateOrigin:(uniforms.project_uCoordinateSystem===_core.COORDINATE_SYSTEM.CARTESIAN?project_uCoordinateOrigin:viewport.projectPosition(project_uCoordinateOrigin)).slice(0,2),fill_patternMask:_opts$fillPatternMask,fill_patternEnabled:opts}}return{}}}}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$extensions$dist$es5$fill_style$shaders_glsl.js.map
