shadow$provide.module$node_modules$$loaders_DOT_gl$terrain$dist$es5$lib$parse_quantized_mesh=function(global,require,module,exports){global=require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard");module=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=function(arrayBuffer,options){if(arrayBuffer){var bounds=options["quantized-mesh"].bounds,_decode=(0,_decodeQuantizedMesh["default"])(arrayBuffer,
_decodeQuantizedMesh.DECODING_STEPS.triangleIndices);arrayBuffer=_decode.triangleIndices;options=_decode.vertexData;var header=_decode.header;_decode=header.minHeight;var maxHeight=header.maxHeight;bounds=bounds||[0,0,1,1];var _ref2=(0,_slicedToArray2["default"])(bounds,4);bounds=_ref2[0];header=_ref2[1];var xScale=_ref2[2]-bounds;_ref2=_ref2[3]-header;maxHeight-=_decode;for(var nCoords=options.length/3,positions=new Float32Array(3*nCoords),texCoords=new Float32Array(2*nCoords),i=0;i<nCoords;i++){var x=
options[i]/32767,y=options[i+nCoords]/32767,z=options[i+2*nCoords]/32767;positions[3*i]=x*xScale+bounds;positions[3*i+1]=y*_ref2+header;positions[3*i+2]=z*maxHeight+_decode;texCoords[2*i]=x;texCoords[2*i+1]=y}options={POSITION:{value:positions,size:3},TEXCOORD_0:{value:texCoords,size:2}};arrayBuffer={loaderData:{header:{}},header:{vertexCount:arrayBuffer.length,boundingBox:(0,_loaderUtils.getMeshBoundingBox)(options)},mode:4,indices:{value:arrayBuffer,size:1},attributes:options}}else arrayBuffer=
null;return arrayBuffer};var _slicedToArray2=module(require("module$node_modules$$babel$runtime$helpers$slicedToArray")),_loaderUtils=require("module$node_modules$$loaders_DOT_gl$loader_utils$dist$es5$index"),_decodeQuantizedMesh=global(require("module$node_modules$$loaders_DOT_gl$terrain$dist$es5$lib$decode_quantized_mesh"))}
//# sourceMappingURL=module$node_modules$$loaders_DOT_gl$terrain$dist$es5$lib$parse_quantized_mesh.js.map
