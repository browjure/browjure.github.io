shadow$provide.module$node_modules$$mapbox$martini$martini=function(global$jscomp$0,require,module,exports){(function(global,factory){"object"===typeof exports&&"undefined"!==typeof module?module.exports=factory():"function"===typeof define&&define.amd?define(factory):(global=global||self,global.Martini=factory())})(this,function(){class Martini{constructor(gridSize=257){this.gridSize=gridSize;const tileSize=gridSize-1;if(tileSize&tileSize-1)throw Error(`Expected grid size to be 2^n+1, got ${gridSize}.`);
this.numTriangles=tileSize*tileSize*2-2;this.numParentTriangles=this.numTriangles-tileSize*tileSize;this.indices=new Uint32Array(this.gridSize*this.gridSize);this.coords=new Uint16Array(4*this.numTriangles);for(gridSize=0;gridSize<this.numTriangles;gridSize++){var id=gridSize+2;let ax=0,ay=0,bx=0,by=0,cx=0,cy=0;for(id&1?bx=by=cx=tileSize:ax=ay=cy=tileSize;1<(id>>=1);){const mx=ax+bx>>1,my=ay+by>>1;id&1?(bx=ax,by=ay,ax=cx,ay=cy):(ax=bx,ay=by,bx=cx,by=cy);cx=mx;cy=my}id=4*gridSize;this.coords[id+0]=
ax;this.coords[id+1]=ay;this.coords[id+2]=bx;this.coords[id+3]=by}}createTile(terrain){return new Tile(terrain,this)}}class Tile{constructor(terrain,martini){const size=martini.gridSize;if(terrain.length!==size*size)throw Error(`Expected terrain data of length ${size*size} (${size} x ${size}), got ${terrain.length}.`);this.terrain=terrain;this.martini=martini;this.errors=new Float32Array(terrain.length);this.update()}update(){const {numTriangles,numParentTriangles,coords,gridSize:size}=this.martini,
{terrain,errors}=this;for(let i=numTriangles-1;0<=i;i--){var k=4*i;const ax=coords[k+0],ay=coords[k+1],bx=coords[k+2];k=coords[k+3];var mx=ax+bx>>1;const my=ay+k>>1,cx=mx+my-ay,cy=my+ax-mx;mx=my*size+mx;errors[mx]=Math.max(errors[mx],Math.abs((terrain[ay*size+ax]+terrain[k*size+bx])/2-terrain[mx]));i<numParentTriangles&&(errors[mx]=Math.max(errors[mx],errors[(ay+cy>>1)*size+(ax+cx>>1)],errors[(k+cy>>1)*size+(bx+cx>>1)]))}}getMesh(maxError=0){function countElements(ax,ay,bx,by,cx,cy){const mx=ax+bx>>
1,my=ay+by>>1;1<Math.abs(ax-cx)+Math.abs(ay-cy)&&errors[my*size+mx]>maxError?(countElements(cx,cy,ax,ay,mx,my),countElements(bx,by,cx,cy,mx,my)):(indices[ay*size+ax]=indices[ay*size+ax]||++numVertices,indices[by*size+bx]=indices[by*size+bx]||++numVertices,indices[cy*size+cx]=indices[cy*size+cx]||++numVertices,numTriangles++)}function processTriangle(ax,ay,bx,by,cx,cy){var mx=ax+bx>>1,my=ay+by>>1;if(1<Math.abs(ax-cx)+Math.abs(ay-cy)&&errors[my*size+mx]>maxError)processTriangle(cx,cy,ax,ay,mx,my),processTriangle(bx,
by,cx,cy,mx,my);else{mx=indices[ay*size+ax]-1;my=indices[by*size+bx]-1;const c=indices[cy*size+cx]-1;vertices[2*mx]=ax;vertices[2*mx+1]=ay;vertices[2*my]=bx;vertices[2*my+1]=by;vertices[2*c]=cx;vertices[2*c+1]=cy;triangles[triIndex++]=mx;triangles[triIndex++]=my;triangles[triIndex++]=c}}const {gridSize:size,indices}=this.martini,{errors}=this;let numVertices=0,numTriangles=0;const max=size-1;indices.fill(0);countElements(0,0,max,max,max,0);countElements(max,max,0,0,0,max);const vertices=new Uint16Array(2*
numVertices),triangles=new Uint32Array(3*numTriangles);let triIndex=0;processTriangle(0,0,max,max,max,0);processTriangle(max,max,0,0,0,max);return{vertices,triangles}}}return Martini})}
//# sourceMappingURL=module$node_modules$$mapbox$martini$martini.js.map
