shadow$provide.module$node_modules$$deck_DOT_gl$aggregation_layers$dist$es5$utils$gpu_grid_aggregation$aggregate_to_grid_vs_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="#define SHADER_NAME gpu-aggregation-to-grid-vs\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute vec3 weights;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform bool projectPoints;\nuniform vec2 translation;\nuniform vec3 scaling;\n\nvarying vec3 vWeights;\n\nvec2 project_to_pixel(vec4 pos) {\n  vec4 result;\n  pos.xy \x3d pos.xy/pos.w;\n  result \x3d pos + vec4(translation, 0., 0.);\n  result.xy \x3d scaling.z \x3e 0. ? result.xy * scaling.xy : result.xy;\n  return result.xy;\n}\n\nvoid main(void) {\n\n  vWeights \x3d weights;\n\n  vec4 windowPos \x3d vec4(positions, 1.);\n  if (projectPoints) {\n    windowPos \x3d project_position_to_clipspace(positions, positions64Low, vec3(0));\n  }\n\n  vec2 pos \x3d project_to_pixel(windowPos);\n\n  vec2 pixelXY64[2];\n  pixelXY64[0] \x3d vec2(pos.x, 0.);\n  pixelXY64[1] \x3d vec2(pos.y, 0.);\n  vec2 gridXY64[2];\n  gridXY64[0] \x3d div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\n  gridXY64[1] \x3d div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\n  float x \x3d floor(gridXY64[0].x);\n  float y \x3d floor(gridXY64[1].x);\n  pos \x3d vec2(x, y);\n  pos \x3d (pos * (2., 2.) / (gridSize)) - (1., 1.);\n  vec2 offset \x3d 1.0 / gridSize;\n  pos \x3d pos + offset;\n\n  gl_Position \x3d vec4(pos, 0.0, 1.0);\n  gl_PointSize \x3d 1.0;\n}\n"}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$aggregation_layers$dist$es5$utils$gpu_grid_aggregation$aggregate_to_grid_vs_glsl.js.map
