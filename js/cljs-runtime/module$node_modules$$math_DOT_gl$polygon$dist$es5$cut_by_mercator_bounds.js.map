{
"version":3,
"file":"module$node_modules$$math_DOT_gl$polygon$dist$es5$cut_by_mercator_bounds.js",
"lineCount":12,
"mappings":"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",
"sources":["node_modules/@math_DOT_gl/polygon/dist/es5/cut-by-mercator-bounds.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$math_DOT_gl$polygon$dist$es5$cut_by_mercator_bounds\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cutPolylineByMercatorBounds = cutPolylineByMercatorBounds;\nexports.cutPolygonByMercatorBounds = cutPolygonByMercatorBounds;\n\nvar _cutByGrid = require(\"./cut-by-grid\");\n\nvar _utils = require(\"./utils\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar DEFAULT_MAX_LATITUDE = 85.051129;\n\nfunction cutPolylineByMercatorBounds(positions) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      _options$startIndex = options.startIndex,\n      startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex,\n      _options$endIndex = options.endIndex,\n      endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex,\n      _options$normalize = options.normalize,\n      normalize = _options$normalize === void 0 ? true : _options$normalize;\n  var newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  var parts = (0, _cutByGrid.cutPolylineByGrid)(newPositions, {\n    size: size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    var _iterator = _createForOfIteratorHelper(parts),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var part = _step.value;\n        shiftLongitudesIntoRange(part, size);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return parts;\n}\n\nfunction cutPolygonByMercatorBounds(positions, holeIndices) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2,\n      _options$normalize2 = options.normalize,\n      normalize = _options$normalize2 === void 0 ? true : _options$normalize2,\n      _options$edgeTypes = options.edgeTypes,\n      edgeTypes = _options$edgeTypes === void 0 ? false : _options$edgeTypes;\n  holeIndices = holeIndices || [];\n  var newPositions = [];\n  var newHoleIndices = [];\n  var srcStartIndex = 0;\n  var targetIndex = 0;\n\n  for (var ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    var srcEndIndex = holeIndices[ringIndex] || positions.length;\n    var targetStartIndex = targetIndex;\n    var splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (var i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (var _i = srcStartIndex; _i < splitIndex; _i++) {\n      newPositions[targetIndex++] = positions[_i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  var parts = (0, _cutByGrid.cutPolygonByGrid)(newPositions, newHoleIndices, {\n    size: size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes: edgeTypes\n  });\n\n  if (normalize) {\n    var _iterator2 = _createForOfIteratorHelper(parts),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var part = _step2.value;\n        shiftLongitudesIntoRange(part.positions, size);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  var maxLat = -1;\n  var pointIndex = -1;\n\n  for (var i = startIndex + 1; i < endIndex; i += size) {\n    var lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex) {\n  var maxLatitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_MAX_LATITUDE;\n  var firstLng = positions[startIndex];\n  var lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    var p = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    (0, _utils.push)(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    (0, _utils.push)(positions, p);\n    p[0] = firstLng;\n    (0, _utils.push)(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  var prevLng = positions[0];\n  var lng;\n\n  for (var i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    var delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  var refLng;\n  var pointCount = positions.length / size;\n\n  for (var i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  var delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (var _i2 = 0; _i2 < pointCount; _i2++) {\n    positions[_i2 * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","insertPoleVertices","positions","size","startIndex","endIndex","maxLatitude","arguments","undefined","DEFAULT_MAX_LATITUDE","firstLng","lastLng","Math","abs","p","_utils","getPointAtIndex","round","push","sign","wrapLongitudesForShortestPath","prevLng","lng","delta","shiftLongitudesIntoRange","refLng","pointCount","_i2","defineProperty","cutPolylineByMercatorBounds","options","_options$size","_options$startIndex","_options$endIndex","_options$normalize","normalize","newPositions","parts","_cutByGrid","cutPolylineByGrid","broken","gridResolution","gridOffset","_iterator","_step","cutPolygonByMercatorBounds","holeIndices","_options$size2","_options$normalize2","_options$edgeTypes","edgeTypes","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","pointIndex","maxLat","lat","_i","pop","cutPolygonByGrid","_iterator2","_step2"]
}
