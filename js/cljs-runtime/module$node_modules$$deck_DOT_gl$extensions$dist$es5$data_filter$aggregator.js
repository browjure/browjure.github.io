shadow$provide.module$node_modules$$deck_DOT_gl$extensions$dist$es5$data_filter$aggregator=function(global,require,module,exports){function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}));keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=
null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2["default"])(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}return target}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,
"__esModule",{value:!0});exports.supportsFloatTarget=function(gl){return gl.getExtension("EXT_float_blend")&&(gl.getExtension("EXT_color_buffer_float")||gl.getExtension("WEBGL_color_buffer_float"))};exports.getFramebuffer=function(gl,useFloatTarget){return useFloatTarget?new _core.Framebuffer(gl,{width:1,height:1,attachments:(0,_defineProperty2["default"])({},36064,new _core.Texture2D(gl,{format:(0,_core.isWebGL2)(gl)?34836:6408,type:5126,mipmaps:!1}))}):new _core.Framebuffer(gl,{width:256,height:64,
depth:!1})};exports.getModel=function(gl,shaderOptions,useFloatTarget){shaderOptions.defines.NON_INSTANCED_MODEL=1;useFloatTarget&&(shaderOptions.defines.FLOAT_TARGET=1);return new _core.Model(gl,_objectSpread({id:"data-filter-aggregation-model",vertexCount:1,isInstanced:!1,drawMode:0,vs:AGGREGATE_VS,fs:AGGREGATE_FS},shaderOptions))};exports.parameters=void 0;var _defineProperty2=global(require("module$node_modules$$babel$runtime$helpers$defineProperty")),_core=require("module$node_modules$$luma_DOT_gl$core$dist$es5$index"),
AGGREGATE_VS="#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component \x3d 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *\x3d float(filterIndices !\x3d filterPrevIndices);\n    gl_Position \x3d vec4(0.0, 0.0, 0.0, 1.0);\n    vColor \x3d vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *\x3d float(filterIndices.x !\x3d filterPrevIndices.x);\n    float col \x3d filterIndices.x;\n    float row \x3d filterIndices.y * 4.0;\n    float channel \x3d floor(row);\n    row \x3d fract(row);\n    vColor \x3d component * vec4(bvec4(channel \x3d\x3d 0.0, channel \x3d\x3d 1.0, channel \x3d\x3d 2.0, channel \x3d\x3d 3.0));\n    gl_Position \x3d vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize \x3d 1.0;\n}\n",
AGGREGATE_FS="#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value \x3c 0.5) {\n    discard;\n  }\n  gl_FragColor \x3d vColor;\n}\n";exports.parameters={blend:!0,blendFunc:[1,1,1,1],blendEquation:[32774,32774],depthTest:!1}}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$extensions$dist$es5$data_filter$aggregator.js.map
